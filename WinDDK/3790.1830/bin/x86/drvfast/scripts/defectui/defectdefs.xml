<?xml version="1.0"?>
<DefectDefs><DefectDefGroup guid="579e033e-fdc0-48ad-bb21-a42ee09ba86b" id="200" name="Bounds">
		<display>Buffer Overrun</display>
		<doc>
			<P>PRE<i>f</i>ast detects some situations in which buffer overruns occur,
			including array bounds violations.</P>
		</doc>
		<ownerURL>http://anyURL</ownerURL>
		<ownerContact>anyAlias</ownerContact>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 200 -->
		<DefectDef guid="8382165d-32a3-4467-9a3c-e9d4e4710321" id="200" name="INDEX_EXCEEDS_MAX_NONSTACK">
			<description>
				<format>Buffer overrun for buffer %variable%</format>
				<param name="variable" format="'%ls'"/>
			</description>
			<additionalInfo>
				<format>index %number1% exceeds maximum valid index %number2%</format>
				<param name="number1" format="%d" display=""/>
				<param name="number2" format="%d" display=""/>
			</additionalInfo>
			<doc>
				<P>
					This warning indicates that an integer offset into the
					specified array exceeds the maximum bounds of that
					array. This defect may result in random behavior or
					crashes.
				</P>
				<P>
					One common cause of this defect is using an array's size
					as an index into the array. Because C/C++ array indexing
					is zero-based, the maximum legal index into an array is
					one less than the number of array elements.
				</P>
				<P>
					Another common cause for the defect is cut-and-paste
					errors.
				</P>
			</doc>
			<example funcBody="void example_func()" globalDecl="char buff[25]">
				<defectiveSrc><![CDATA[
					buff[sizeof buff] = '\0';    /* error */
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					buff[sizeof buff - 1] = '\0';
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 201 -->
		<DefectDef guid="5ad3f02a-cdf5-48b9-bd5b-24800d6b7e1e" id="201" name="INDEX_EXCEEDS_MAX">
			<description>
				<format>Buffer overrun for stack buffer %variable%</format>
				<param name="variable" format="'%ls'"/>
			</description>
			<additionalInfo>
				<format>index %number1% exceeds maximum valid index %number2%</format>
				<param name="number1" format="%d" display=""/>
				<param name="number2" format="%d" display=""/>
			</additionalInfo>
			<doc>
				<P>This warning indicates that an integer offset into the specified stack array
				exceeds the maximum bounds of that array. This defect may result in random
				behavior or crashes.</P>
				<P>One common cause of this defect is using an array's size as an index into the
				array. Because C/C++ array indexing is zero-based, the maximum legal index
				into an array is one less than the number of array elements.</P>
				<P>Another common cause for the defect is cut-and-paste errors.</P>
			</doc>
			<example funcBody="void example_func()">
				<defectiveSrc><![CDATA[
					char buff[25];

					buff[sizeof buff] = '\0';    /* error */
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					char buff[25];

					buff[sizeof buff - 1] = '\0';
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 202 -->
		<DefectDef guid="34b555e9-1d4f-4d1b-aabf-a6a2317b7772" id="202" name="BUFFER_OVERRUN">
			<description>
				<format>Buffer overrun for stack buffer %variable% in call to %function%</format>
				<param name="variable" format="'%ls'"/>
				<param name="function" format="'%ls'"/>
			</description>
			<additionalInfo>
				<format>length %number1% exceeds buffer size %number2%</format>
				<param name="number1" format="%d" display=""/>
				<param name="number2" format="%d" display=""/>
			</additionalInfo>
			<doc>
				<P>This warning indicates that a parameter pointing to a
				stack buffer of known size is being passed into a function
				that copies more bytes into it than that size. This situation
				will cause a buffer overrun.</P>
				<P>This defect is likely to result in an exploitable
				security hole or a program crash.</P>
				<P>A common cause for the defect is cut-and-paste errors.</P>
				<P>If PRE<i>f</i>ast can determine that the mismatch between
				the length and size is due to confusion between character
				and byte count, it will report the more precise warning
				57.</P>
			</doc>
			<example funcBody="void example_func()" sysIncludes="string.h">
				<defectiveSrc><![CDATA[
					char charArray[5];
					int intArray[5];

					memset ((void *)charArray, 0, sizeof intArray);
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					char charArray[5];
					int intArray[5];

					memset ((void *)charArray, 0, sizeof charArray);
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 203 -->
		<DefectDef guid="32c88443-acc2-47d5-b432-f4244a594f11" id="203" name="BUFFER_OVERRUN_NONSTACK">
			<description>
				<format>
					Buffer overrun for buffer %variable% in call to %function%
				</format>
				<param name="variable" format="'%ls'"/>
				<param name="function" format="'%ls'"/>
			</description>
			<additionalInfo>
				<format>
					length %number1% exceeds buffer size %number2%
				</format>
				<param name="number1" format="%d" display=""/>
				<param name="number2" format="%d" display=""/>
			</additionalInfo>
			<doc>
				<P>
					This warning indicates that a parameter pointing to a
					non-stack buffer of known size is being passed into a
					function that copies more bytes into it than that size.
					This situation will cause a buffer overrun.
				</P>
				<P>
					This defect could result in an exploitable security hole
					or a program crash.
				</P>
				<P>
					If PRE<i>f</i>ast can determine that the mismatch between
					the length and size is due to confusion between character
					and byte count, it will report the more precise warning
					57.
				</P>
			</doc>
			<example funcBody="void example_func()" sysIncludes="string.h">
				<defectiveSrc><![CDATA[
					static char charArray[5];
					static int intArray[5];

					memset ((void *)charArray, 0, sizeof intArray);
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					static char charArray[5];
					static int intArray[5];

					memset ((void *)charArray, 0, sizeof charArray);
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 57 -->
		<DefectDef guid="247d97ab-6a6c-4d65-8bb9-27e76385c559" id="57" name="CHAR_BYTE_SIZE_MISMATCH">
			<description>
				<format>Buffer overrun due to number of characters/number of bytes mismatch in call to %function%</format>
				<param name="function" format="'%ls'"/>
			</description>
			<recommendedFix>
				<format>Parameter %number% should be '(sizeof %variable%)/(sizeof %variable%[0])'</format>
				<param name="number" format="%d" display=""/>
				<param name="variable" format="%ls"/>
			</recommendedFix>
			<doc>
				<P>This warning indicates that a function that expects the number of characters
				is being passed the number of bytes instead. With wide (Unicode) characters the
				values are different. This defect may result in an exploitable buffer overrun or
				crash.</P>
				<P>PRE<i>f</i>ast reports this warning only for a set of
				functions that are known to take a character count rather
				than a byte count, so this warning is extremely accurate. In
				situations where PRE<i>f</i>ast is using a heuristic to
				determine whether a character count is required it reports a
				warning 209 instead, which is potentially less accurate.</P>
				<P>A common cause of this defect is using
				<code>sizeof</code> on a character array. The
				<code>sizeof</code> operator always computes the number of
				bytes; for ANSI characters this is the same as the number of
				characters, but for Unicode characters it is twice the
				number of characters.</P>
				<P>It is usually safe to compute the number of elements in an array by dividing
				the size of the array by the size of each individual element.</P>
			</doc>
			<example sysIncludes="windows.h" funcBody="void char_byte_size_mismatch(HINSTANCE hInst, UINT uID)">
				<defectiveSrc><![CDATA[
					TCHAR buff[128];

					(void)LoadString(hInst,
									 uID,
									 buff,
									 sizeof buff); /* wrong in Unicode case */
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					TCHAR buff[128];

					(void)LoadString(hInst,
									 uID,
									 buff,
									 (sizeof buff)/(sizeof buff[0]));
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 203 -->
		<!--
		<DefectDef guid="e982cf96-9576-4172-8b81-32b168e5926f"
			id="203"
			name="FIELD_BUFFER_OVERRUN">
			<format>Buffer overrun for field '%ls' when calling '%ls': length %d is too large for array size %d</format>
			<display>Buffer overrun for field when calling '<PARAM>function</PARAM>': length is too large for array size</display>
		</DefectDef>

-->
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 56 -->
		<DefectDef guid="5fa7c40f-20c6-4d80-bb85-953d37ebd8eb" id="56" name="USE_SAFER_FUNCTION">
			<description>
				<format>Call to %function% does not validate buffer size</format>
				<param name="function" format="'%ls'"/>
			</description>
			<recommendedFix>
				<format>Consider calling %function% instead</format>
				<param name="function" format="'%ls'"/>
			</recommendedFix>
			<doc>
				<P>This warning indicates that a function such as
				<code>sprintf</code>, which does not have a parameter
				indicating the maximum buffer size and is thus prone to
				buffer overrun, has been called when an alternate function
				that does contain the maximum buffer size exists.</P>
				<P>This warning identifies an opportunity for defensive programming; it
				sometimes identifies a defect that can lead to an exploitable buffer
				overrun or crash.</P>
				<P>PRE<i>f</i>ast attempts to suggest a safer function that can be called as an
				alternative.</P>
			</doc>
			<example funcBody="void example_func(char *input)" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
					char buff[MAX_PATH];

					OemToChar(buff, input);  // if strlen(input) > _MAX_PATH,
											 // leads to buffer overrun
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					char buff[MAX_PATH];

					OemToCharBuff(buff, input, MAX_PATH);
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 204 -->
		<DefectDef guid="254eab11-efde-4861-a103-089f7adde3ba" id="204" name="UNVALIDATED_PARAM">
			<description>
				<format>Possible buffer overrun in call to %function%</format>
				<param name="function" format="'%ls'"/>
			</description>
			<additionalInfo>
				<format>use of unchecked parameter %variable%</format>
				<param name="variable" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<P>This warning indicates that a function call is being made that could
				potentially lead to an overrun of a stack buffer, depending on the
				possible values of parameters to the function being analyzed.</P>
				<P>This defect may result in an exploitable buffer overrun or crash; in
				fact, some high-profile security exploits have been due to this defect.
				However, since PRE<i>f</i>ast does not consider the set of all possible callers
				to the function being analyzed, it is possible that the code is
				completely safe.</P>
				<P>It is a good idea to double-check the code (and the callers to this
				function) to see whether the function can ever be called with unexpected
				data. If it is not clear that all calls are safe, it may be appropriate
				to validate the input to the function (e.g., by checking the length of
				any input strings); conversely, bear in mind that unnecessary validation
				exacts a performance cost. </P>
				<P>It should be noted that for some coding styles many of these warnings
				will prove to be safe after inspection. Because of the frequency and
				potential consequences of this defect, we biased PRE<i>f</i>ast in favor of
				finding potential issues rather than its normal bias of reducing noise.</P>
			</doc>
			<example sysIncludes="string.h" funcBody="void buffer_overrun_due_to_invalidated_param(char *ptr)">
				<defectiveSrc><![CDATA[
					char buff[10];

					strcpy(buff, ptr);
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					char buff[10];

					if (strlen(ptr) >= sizeof buff) {
						return;
					}

					strcpy (buff, ptr);
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 29 -->
		<DefectDef guid="3233b9cd-e5aa-437f-8c64-cbf7ee81d2db" id="29" name="USING_TAINTED_DATA">
			<description>
				<format>Possible buffer overrun in call to %function%</format>
				<param name="function" format="'%ls'"/>
			</description>
			<additionalInfo>
				<format>use of unchecked buffer size %variable%</format>
				<param name="variable" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<P>This warning indicates that a function that takes a buffer and a
				size is being passed a tainted size: data that has been read in from
				some external source and has not been checked to see whether it is
				smaller than the buffer size.</P>
				<P>This defect may result in an exploitable buffer overrun, and has
				led to several high-profile exploits and subsequent patches from
				several different software vendors. An attacker may intentionally put
				a much larger than expected value for the size, which will lead to a
				buffer overrun.</P>
				<P>Whenever reading data from an untrusted external source, make sure
				to check it for validity. In this case, it is usually appropriate to
				check the size to make sure it is in the expected range.</P>
			</doc>
			<example funcBody="void example_func(HANDLE hFile)" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
					char buff[80];
					DWORD cbLen;
					DWORD cbRead;

					if (!ReadFile (hFile, &cbLen, sizeof (cbLen), &cbRead, NULL)) {
						return;
					}

					if (!ReadFile (hFile, buff, cbLen, &cbRead, NULL)) {  // error!
												// Need to check that cbLen <= 80
						return;
					}
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					char buff[80];
					DWORD cbLen;
					DWORD cbRead;

					if (!ReadFile (hFile, &cbLen, sizeof (cbLen), &cbRead, NULL)) {
						return;
					}

					if (cbLen &gt; sizeof (buff)) {
						return;  // possibly after doing some error handling
					}

					if (!ReadFile (hFile, buff, cbLen, &cbRead, NULL)) {
						return;
					}
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 205 -->
		<DefectDef guid="ceff88d7-c73c-45b4-a0b0-8dd9251c0f31" id="205" name="STACK_BUFFER_DANGEROUS_FUNCTION">
			<description>
				<format>Stack buffer overrun of %variable% in call to dangerous function %function%</format>
				<param name="variable" format="'%ls'"/>
				<param name="function" format="'%ls'"/>
			</description>
			<doc>
				<P>This warning indicates that a stack variable is being passed into
				function that gives no way of controlling how many bytes are copied
				into a buffer (e.g., <code>gets</code>).</P>
				<P>This defect is likely to result in an exploitable security hole or
				a program crash.</P>
				<P>Take care when making the changes to ensure that the code behaves
				correctly in the case of very long data - it is surprisingly easy to
				fix the buffer overrun and silence PRE<i>f</i>ast but wind up with code that
				still behaves incorrectly. A useful technique for helping to address
				problem is often to use a function that includes the buffer size
				(e.g., <code>fgets</code> or <code>_fgetws</code>) instead; make sure to handle the case where
				the length of the data exceeds the buffer size. In some cases, more
				significant changes may be required.</P>
			</doc>
			<example funcBody="void Bounds_%id%()" sysIncludes="stdlib.h;stdio.h">
				<defectiveSrc><![CDATA[
					char buff[_MAX_PATH];

					if (! gets(buff))    // but what if something longer than
					{;}                  // _MAX_PATH is provided as input?
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					char buff[_MAX_PATH];

					if (! fgets(buff, sizeof buff, stdin))
					{;}
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 206 -->
		<!-- not in 1.0
		<DefectDef guid="5ff8be30-96ca-4901-ad7d-4d66cec8490d"
			id="206"
			name="PARAM_BUFFER_DANGEROUS_FUNCTION">
			<format>Parameter buffer overrun when calling dangerous function '%ls': '%ls' '%ls'</format>
			<display>Parameter buffer overrun when calling dangerous function</display>
		</DefectDef>
-->
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 207 -->
		<DefectDef guid="814bf142-97b8-4d2b-bdd4-dd0fcfacea19" id="207" name="GENERIC_OVERRUN_DANGEROUS_FUNCTION">
			<description>
				<format>Buffer overrun in call to dangerous function %function%</format>
				<param name="function" format="'%ls'"/>
			</description>
			<doc>
				<P>This warning indicates that a buffer is being passed into
				function that gives no way of controlling how many bytes are
				copied into a buffer (e.g., <code>gets</code> or
				<code>_getws</code>).</P>
				<P>This defect is likely to result in a memory corruption or
				program crash, although in some cases may result in an
				exploitable security hole.</P>
				<P>Take care when making the changes to ensure that the code
				behaves correctly in the case of very long data - it is
				surprisingly easy to fix the buffer overrun and silence
				PRE<i>f</i>ast but wind up with code that still behaves
				incorrectly. A useful technique for helping to address
				problem is often to use a function that includes the buffer
				size (e.g., <code>fgets</code> or <code>_fgetws</code>)
				instead; make sure to handle the case where the length of
				the data exceeds the buffer size. In some cases, more
				significant changes may be required.</P>
				<P>If PRE<i>f</i>ast can determine that the buffer being
				passed in is a stack buffer (in which case it is more likely
				to result in an exploitable security hole), the more precise
				warning 205 will be reported instead.</P>
			</doc>
			<example funcBody="void Bounds_%id%()" sysIncludes="stdlib.h;stdio.h">
				<defectiveSrc><![CDATA[
					static char buff[_MAX_PATH];

					if (! gets(buff))    // but what if something longer than
					{;}                  // _MAX_PATH is provided as input?
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					static char buff[_MAX_PATH];

					if (! fgets(buff, sizeof buff, stdin))
					{;}
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 208 -->
		<!-- not in 1.0
		<DefectDef guid="bca84351-cadc-44c9-92db-a88e57ca51cc"
			id="208"
			name="STACK_BUFFER_TO_FUNCTION">
			<format>Stack buffer passed to function '%ls': '%ls' '%ls' '%ls'</format>
			<display>Stack buffer passed to function</display>
		</DefectDef>
-->
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 209 -->
		<DefectDef guid="69DF4C70-A4E5-4051-8C2C-F41A623CC62D" id="209" name="SIZEOF_CHAR_BYTE_SIZE_MISMATCH">
			<description>
				<format>Using 'sizeof %variable1%' as parameter %number% in call to %function% where %variable2% is an array of wide characters</format>
				<param name="variable1" format="%ls"/>
				<param name="number" format="%d" display=""/>
				<param name="function" format="'%ls'"/>
				<param name="variable2" format="'%ls'"/>
			</description>
			<question>
				<format>Should this be character count rather than byte count</format>
			</question>
			<doc>
				<p>
					This warning indicates PRE<i>f</i>ast has identified a
					parameter to a function call that may incorrectly be a
					byte count instead of a character count.  If this is the
					case, this defect is likely to result in a memory
					corruption or program crash, although some cases may
					result in an exploitable security hole.
				</p>
				<p>
					It should be noted that the heuristic PRE<i>f</i>ast
					uses can be incorrect for certain coding styles;
					therefore, this warning may not correspond to an actual
					defect in the code.
				</p>
				<p>
					A common cause of this defect is using sizeof on a
					character array. The <code>sizeof</code> operator yields
					the number of bytes requires to store the object. For
					ANSI characters, this is the same as the number of
					characters; however, for Unicode characters it is twice
					the number of characters.
				</p>
				<p>
					It is usually safe to compute the number of elements in
					an array by dividing the size of the array by the size
					of each individual element.
				</p>
				<p>
					If PRE<i>f</i>ast knows that the specific function
					involved definitely takes a character count rather than
					a byte count, it produces the more precise warning 53
					instead.
				</p>
				<p>
					PRE<i>f</i>ast generates this warning in cases when:

					<ul>
						<li>
							a variable is passed as one parameter and
							<code>sizeof</code> that variable is passed as
							another parameter;
						</li>
						<li>
							both the variable type and the formal parameter
							type are some variety of pointer-to-wide char.
						</li>
					</ul>
				</p>
			</doc>
			<example funcBody="void example_func(wchar_t *input)" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
					extern void my_wcsncpy(wchar_t *, wchar_t *, size_t);
					WCHAR pPtr1[5];

					my_wcsncpy(pPtr1, input, sizeof pPtr1);
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					extern void my_wcsncpy(wchar_t *, wchar_t *, size_t);
					WCHAR pPtr1[5];

					my_wcsncpy(pPtr1, input, (sizeof pPtr1) / (sizeof pPtr1[0]));
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="c7e5b217-bf45-4f56-8370-e63d7d2e6a39" id="292" name="LOOP_COUNTS_UP_FROM_MAX">
			<description>
				<format>
					Ill-defined for-loop
				</format>
			</description>
			<additionalInfo>
				<format>
					counts up from "maximum"
				</format>
			</additionalInfo>
			<doc>
				<p>
					This warning indicates that PRE<i>f</i>ast has detected
					a for-loop that may not function as intended.
				</p>
				<p>
					This warning occurs when a loop that counts up from a
					maximum, but has a lower termination condition is
					detected.  This loop will terminate only after integer
					overflow occurs.
				</p>
			</doc>
			<example funcBody="void Bounds_%id%()">
				<defectiveSrc><![CDATA[
					signed char i;

					for (i = 100; i >= 0; i++) { ; }
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					signed char i;

					for (i = 100; i >= 0; i--) { ; }
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="c901eef0-d4d7-4e44-be0e-3e00d2287850" id="293" name="LOOP_INDEX_GOES_NEGATIVE">
			<description>
				<format>
					Ill-defined for-loop
				</format>
			</description>
			<additionalInfo>
				<format>
					counts down from "minimum"
				</format>
			</additionalInfo>
			<consequence>
				<format>
					Loop control variable goes negative
				</format>
			</consequence>
			<doc>
				<p>
					This warning indicates that PRE<i>f</i>ast has detected
					a for-loop that may not function as intended.
				</p>
				<p>
					A signed index variable in conjunction with a negative
					increment will cause the loop to count negative until
					integer overflow occurs which will terminate the loop.
				</p>
			</doc>
			<example funcBody="void Bounds_%id%()">
				<defectiveSrc><![CDATA[
					signed char i;

					for (i = 0; i < 100; i--) { ; }
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					signed char i;

					for (i = 0; i < 100; i++) { ; }
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="69632d82-65c9-420b-8790-550e2e0abc7a" id="294" name="LOOP_BODY_NEVER_EXECUTED">
			<description>
				<format>
					Ill-defined for-loop
				</format>
			</description>
			<additionalInfo>
				<format>
					initial condition does not satisfy test
				</format>
			</additionalInfo>
			<consequence>
				<format>
					Body not executed
				</format>
			</consequence>
			<doc>
				<p>
					This warning indicates that PRE<i>f</i>ast has detected
					a for-loop that may not function as intended.
				</p>
				<p>
					The for-loop:
	<pre>
		for (<i>initializer</i>; <i>continuation</i>; <i>increment</i> ) {
			...
		}
	</pre>
	is equivalent to the following:
	<pre>
		{
			<i>initializer</i>;
			while (<i>continuation</i>) {
				...
				<i>increment</i>;
			}
		}
	</pre>
				</p>
				<p>
					Thus, if <i>initializer</i> does not satisfy
					<i>continuation</i>, the loop body will not be executed.
				</p>
			</doc>
			<example funcBody="void Bounds_%id%()">
				<defectiveSrc><![CDATA[
					signed char i;

					for (i = 0; i > 100; i++) { ; }
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					signed char i;

					for (i = 0; i < 100; i++) { ; }
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="965b6e54-52b8-42ec-a2b9-3e5f56bbb98c" id="295" name="INFINITE_LOOP">
			<description>
				<format>
					Ill-defined for-loop
				</format>
			</description>
			<additionalInfo>
				<format>
					unsigned values are always &gt;= 0
				</format>
			</additionalInfo>
			<consequence>
				<format>
					Loops infinitely
				</format>
			</consequence>
			<doc>
				<p>
					This warning indicates that PRE<i>f</i>ast has detected
					a for-loop that may not function as intended.
				</p>
				<p>
					The for loop tests an unsigned value against zero (0) with
					<code>&gt;=</code>.  The result is always <code>true</code>
					so the loop is infinite.
				</p>
			</doc>
			<example funcBody="void Bounds_%id%()">
				<defectiveSrc><![CDATA[
					unsigned char i;

					for (i = 100; i >= 0; i--) { ; }
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					unsigned char i;

					for (i = 100; i > 0; i--) { ; }
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="b1c6d59e-ff91-4f62-a0ff-433f47cb8059" id="296" name="LOOP_ONLY_EXECUTED_ONCE">
			<description>
				<format>
					Ill-defined for-loop
				</format>
			</description>
			<consequence>
				<format>
					Body only executed once
				</format>
			</consequence>
			<doc>
				<p>
					This warning indicates that PRE<i>f</i>ast has detected
					a for-loop that may not function as intended.
				</p>
				<p>
					When the index is unsigned and a loop counts down from
					from zero, it's body is executed only once.
				</p>
			</doc>
			<example funcBody="void Bounds_%id%()">
				<defectiveSrc><![CDATA[
					unsigned char			i;

					for (i = 0; i < 100; i--) { ; }
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					unsigned char			i;

					for (i = 0; i < 100; i++) { ; }
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="3496220c-7d5d-48ac-8de2-adea987ec41b" id="311" name="USE_OTHER_FUNCTION">
			<description>
				<format>Consider using %function% instead of %function%. Reason: %reason%</format>
				<param name="function" format="'%ls'"/>
				<param name="reason" format="%ls"/>
			</description>
			<doc>
				<P>This warning suggests a preferred function calls that
				that may be semantically equivalent to the existing function call.</P>
			</doc>
			<example funcBody="void example_func(char *input)" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
					char buff[MAX_PATH];

					OemToChar(buff, input);  // if strlen(input) > MAX_PATH,
											 // leads to buffer overrun
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					char buff[MAX_PATH];

					OemToCharBuff(buff, input, MAX_PATH);
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- Removed "review" messages for WinHEC DDK release (to match Win2003 DDK) -->
		<DefectDef guid="9542be9b-305f-4485-a1d8-f95cda3f8267" id="383" name="ELEMENTS_TO_BYTES">
			<description>
				<format>Buffer overrun due to conversion of an element count
				into a byte count</format>
			</description>
			<additionalInfo>
				<format> an element count is expected for parameter
				%index% in call to %function%</format>
				<param name="index" format="'%d'"/>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<p>
					This warning is flagged when PRE<i>f</i>ast can
					determine that a non-constant byte count is being passed
					when an element count is required.
				</p>
				<p>
					Typically this occurs when a variable is multiplied by
					the sizeof a type, but other information suggests
					that an element count is required.
				</p>
			</doc>
			<example funcBody="int Precedence_%id%(TCHAR *src, int size)" sysincluded="windows.h">
				<defectiveSrc><![CDATA[
					LPTSTR		dest = malloc(Size * sizeof (TCHAR));

					if (dest) {
						_tcsncpy(dest, src, Size * sizeof (TCHAR));
					}
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					LPTSTR		dest = malloc(Size * sizeof (TCHAR));

					if (dest) {
						_tcsncpy(dest, src, Size);
					}
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="5abb1cde-08f4-4aa1-a646-86f7855fe376" id="384" name="DIVIDING_SIZEOF_POINTER">
			<description>
				<format>
					Dividing sizeof a pointer by another value
				</format>
			</description>
			<doc>
				<p>
					This warning indicates that PRE<i>f</i>ast has detected
					a size calculation that may be incorrect.
				</p>
				<p>
					To calculate the number of elements in an array, one
					sometimes divides the size of the array by the size of
					the first element.  But when the array is actually a
					pointer, the result typically different than intended.
				</p>
				<p>
					If the pointer is a function parameter and the size of
					the buffer was not passed, it is not possible to
					calculate the maximum buffer available.
				</p>
				<p>
					When the pointer is allocated locally, the size used in
					the allocation should be used.
				</p>
			</doc>
			<example funcBody="int Precedence_%id%(TCHAR *src)" sysincluded="windows.h">
				<defectiveSrc><![CDATA[
					LPTSTR		dest = new TCHAR[15];

					if (dest) {
						_tcsncpy(dest, src, sizeof a / sizeof a[0]);
					}
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					LPTSTR		dest = new TCHAR[15];

					if (dest) {
						_tcsncpy(dest, src, 15);
					}
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
	</DefectDefGroup>
	<DefectDefGroup guid="df27e65d-c120-4d7c-b7a9-946b49790de2" id="210" name="dfa">
		<doc>
			<p>
                PRE<i>f</i>ast detects defects such
                as use of uninitialized memory, NULL pointer dereferences,
                and resource leaks.
            </p>
		</doc>
		<ownerURL>http://anyURL</ownerURL>
		<ownerContact>anyAlias</ownerContact>
		<!--  -->
		<DefectDef guid="740d585c-ceb6-489e-9b35-04d493dec617" id="1" name="USING_UNINIT_VAR">
			<description>
				<format>
                    Using uninitialized memory %variable%
                </format>
				<param name="variable" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    The warning indicates that the specified variable has
                    been used without being initialized.
                </p>
				<p>
                    Note that this warning is currently reported on all
                    lines where the uninitialized variable is used.
                </p>
			</doc>
			<example funcBody="void Dfa_1">
				<defectiveSrc><![CDATA[
                    int i;

                    i++;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    int i = 0;

                    i++;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_1.htm</helpURL>
		</DefectDef>
		<!--  -->
		<DefectDef guid="dd8f2ca5-f8d0-4a5e-86db-91c766348104" id="11" name="DEREF_NULL_PTR">
			<description>
				<format>
                    Dereferencing  NULL pointer %pointer%
                </format>
				<param name="pointer" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    This warning indicates that the specified pointer is
                    being dereferenced, but may be a NULL pointer.
                </p>
			</doc>
			<example funcBody="void Dfa_11" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    char    *p = (char *)malloc(10);

                    *p = '\0';
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char    *p = (char *)malloc(10);

                    if (p) {
                        *p = '\0';
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_11.htm</helpURL>
		</DefectDef>
		<!--  -->
		<DefectDef guid="a614ced5-b0e7-4aec-b256-79bbc0b19c5f" id="14" name="MEMORY_LEAK">
			<description>
				<format>
                    Leaking memory %pointer%
                </format>
				<param name="pointer" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    This warning indicates that the specified pointer points
                    to allocated memory that has not been freed.
					PRE<i>f</i>ast only shows the first of possibly several
					similar warnings; rerunning PRE<i>f</i>ast after fixing
					a leak may expose another leak originating from the same
					allocation.
                </p>
				<p>
					The test for the function that frees is less strict
					than in Warning 15, and this warning is retained for
					historical differentiation.  See Warning 15.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    char *p = (char *)malloc(10);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char *p = (char *)malloc(10);

                    free(p);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8103 -->
		<!-- (temporary number, probably) -->
		<DefectDef guid="B89B937F-F74C-4700-8562-E9203485F4FB" id="8103" name="RESOURCE_LEAK">
			<description>
				<format>
                    Leaking the resource stored in %pointer%
                </format>
				<param name="pointer" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    This warning indicates that the specified object 
                    contains some allocated resource that has not been freed.
					PRE<i>f</i>ast only shows the first of possibly several
					similar warnings; rerunning PRE<i>f</i>ast after fixing
					a leak may expose another leak originating from the same
					allocation.
                </p>
				<p>
					For resources which are not allocated into a variable
					(for example, some spin locks), PRE<i>f</i>ast has synthesized
					a name, which when combined with the path should
					clearly idenitify the leaking resource.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    res = KeSaveFloatingPointState(buffer);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    res = KeSaveFloatingPointState(buffer);
					if (NT_SUCCESS(res))
					{

                        res = KeRestoreFloatingPointState(buffer);
					}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8104 -->
		<!-- (temporary number, probably) -->
		<DefectDef guid="1B3E4F58-45F6-46fe-BD58-2D394B3FD833" id="8104" name="MAYBE_LEAK">
			<description>
				<format>
                    Possibly leaking memory %pointer%
                </format>
				<param name="pointer" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    This warning indicates that the specified pointer points
                    to allocated memory that has not been explicitly freed,
					but which has been passed to a function that might have
					freed it or inserted it in to some data structure.
                </p>
				<p>
					This warning can be ignored if the indicated path takes
					it through a function that is known to free the object
					or which saves it in a way that it will be freed later.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    char *p = (char *)malloc(10);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char *p = (char *)malloc(10);

                    push_back(p);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<DefectDef guid="414f4332-9e21-4f09-b7c0-7ff0d883a17d" id="211" name="MEMORY_LEAK_EXCEPTION">
			<description>
				<format>
                    Leaking memory %pointer% due to an exception
                </format>
				<param name="pointer" format="'%ls'"/>
			</description>
			<question>
				<format>
                    Is a local catch block needed to clean up memory
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that allocated memory is not
                    being freed when an exception is thrown.  The statement
                    at the end of the path could potentially throw an
                    exception.

					PRE<i>f</i>ast only shows the first of possibly several
					similar warnings; rerunning PRE<i>f</i>ast after fixing
					a leak may expose another leak originating from the same
					allocation.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%" sysIncludes="new">
				<defectiveSrc><![CDATA[
                    char *p1 = new char[10];
                    char *p2 = new char[10];

                    delete[] p2;
                    delete[] p1;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char *p1 = new char[10];
                    char *p2;

                    try {
                        p2 = new char[10];
                    } catch (std::bad_alloc *e) {
                        // just handle the throw.
                        ;
                    }

                    delete[] p2;
                    delete[] p1;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8105 -->
		<!-- (temporary number, probably) -->
		<DefectDef guid="145B1056-1169-457f-AEBC-3F635B9F616E" id="8105" name="RESOURCE_LEAK_EXCEPTION">
			<description>
				<format>
                    Leaking resource in %pointer% due to an exception
                </format>
				<param name="pointer" format="'%ls'"/>
			</description>
			<question>
				<format>
                    Is a local catch block needed to clean up memory
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that some resource is not
                    being freed when an exception is thrown.  The statement
                    at the end of the path could potentially throw an
                    exception.
					PRE<i>f</i>ast only shows the first of possibly several
					similar warnings; rerunning PRE<i>f</i>ast after fixing
					a leak may expose another leak originating from the same
					allocation.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%" sysIncludes="new">
				<defectiveSrc><![CDATA[
					res = AllocateResource(Resource);
                    char *p2 = new char[10]; // could throw

                    delete[] p2;
					FreeResource(Resource)
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					res = AllocateResource(Resource);
                    char *p2;

                    try {
                        p2 = new char[10];
                    } catch (std::bad_alloc *e) {
                        // just handle the throw.
                        ;
                    }
					FreeResource(Resource)

                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8106 -->
		<!-- (temporary number, probably) -->
		<DefectDef guid="1B3E4F58-45F6-46fe-BD58-2D394B3FD833" id="8106" name="MAYBE_LEAK_EXCEPTION">
			<description>
				<format>
                    Possibly leaking memory %pointer% due to an exception
                </format>
				<param name="pointer" format="'%ls'"/>
			</description>
			<question>
				<format>
                    Is a local catch block needed to clean up memory
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that allocated memory may not be
                    being freed when an exception is thrown.
                    It indicates that the specified pointer points
                    to allocated memory that has not been explicitly freed,
					but which has been passed to a function that might have
					freed it or inserted it in to some data structure.
                </p>
				<p>
					This warning can be ignored if the indicated path takes
					it through a function that is known to free the object
					or which saves it in a way that it will be freed later.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%" sysIncludes="new">
				<defectiveSrc><![CDATA[
                    char *p1 = new char[10];
                    char *p2 = new char[10];  // could throw

                    delete[] p2;
                    delete[] p1;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char *p1 = new char[10];
					structure::push_back(p1);
                    char *p2;

                    try {
                        p2 = new char[10];
                    } catch (std::bad_alloc *e) {
                        // just handle the throw.
                        ;
                    }

                    delete[] p2;
                    delete[] p1;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<DefectDef guid="025d34f2-fd00-45f4-8304-6817cd7a9219" id="305" name="SIZEOF_COUNTOF_MISMATCH">
			<description>
				<format>
                    Potential mismatch between sizeof and countof quantities
                </format>
			</description>
			<doc>
				<p>
                    This warning indicates that a variable holding a sizeof
					result is being added to or subtracted from a countof
					expression. This will cause unexpected scaling in pointer
					arithmetic.
                </p>
			</doc>
			<example funcBody="void Dfa_305(void *some_array)">
				<defectiveSrc><![CDATA[
                    struct S {int a; int b;} *p = (struct S *)some_array;
					int cb = sizeof(struct S);
					p += cb;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    struct S {int a; int b;} *p = (struct S *)some_array;
					p += 1;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_305.htm</helpURL>
		</DefectDef>
		<!--  -->
		<DefectDef guid="92f4c57d-5784-4c0d-9cd1-56fa48f57953" id="59" name="BAD_CONCATENATION">
			<description>
				<format>Misuse of length parameter in call to %function%</format>
				<param name="function" format="'%ls'"/>
			</description>
			<recommendedFix>
				<format>Pass the number of remaining characters, not the buffer size of %variable%</format>
				<param name="variable" format="'%ls'"/>
			</recommendedFix>
			<doc>
				<P>This warning indicates that PRE<i>f</i>ast has detected a
				call to a string concatenation function that is probably
				passing an incorrect value for the number of characters to
				concatenate. Although it may seem counterintuitive,
				functions such as <code>strncat</code> and
				<code>wcsncat</code> take the maximum number of parameters
				to concatenate - not the size of the buffer.</P>
				<P>This defect may result in an exploitable buffer overrun or crash.</P>
				<P>A common cause of this defect is passing the buffer size, rather than
				the remaining number of characters in the buffer, to the string
				manipulation function.</P>
			</doc>
			<example sysIncludes="string.h" funcBody="void bad_concatenation(char *arg1, char *arg2)">
				<defectiveSrc><![CDATA[
					char arr[10];

					arr[9] = 0;
					strncpy(arr, arg1, 9);
					strncat(arr, arg2, 10); /* wrong: this says to copy 10 chars */
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					char arr[10];

					arr[9] = 0;
					strncpy(arr, arg1, 9);
					strncat(arr, arg2, 9 - strlen(arr));
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_59.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="635c304a-3e2c-4119-823f-8ff89195f979" id="53" name="MISSING_ZERO_TERMINATION">
			<description>
				<format>Call to %function% may not zero-terminate string %variable%</format>
				<param name="function" format="'%ls'"/>
				<param name="variable" format="'%ls'"/>
			</description>
			<doc>
				<P>This warning indicates that a function such as strncpy has been called
				in such a way that the resulting string may not be zero-terminated. This
				defect may result in an exploitable buffer overrun or crash.</P>
				<P>Most C standard library and Win32 string handling
				functions require and produce zero-terminated strings. A few
				'counted string' functions (including <code>strncpy</code>,
				<code>_wcsncpy</code>, <code>_mbsncpy</code>,
				<code>strncat</code>, <code>_wcsncat</code>,
				<code>_mbsncat</code>, <code>mbstowcs</code>, and
				<code>wcstombs</code>) do not produce zero-terminated
				strings if they exactly fill their buffer. In this case, a
				subsequent call to a string function that expects to see a
				zero-termination will run off the end of the buffer looking
				for the zero.</P>
				<P>The program should make sure that the string ends with a zero. In
				general, one useful approach is to pass a length to the 'counted string'
				function one smaller than the size of the buffer and then explicitly
				assign zero to the last character in the buffer.</P>
				<P>You should note that there is a known problem that
				sometimes causes PRE<i>f</i>ast to report this warning on
				certain idioms guaranteed to be safe in practice. Because of
				the frequency and potential consequences of this defect, we
				biased PRE<i>f</i>ast in favor of finding potential issues
				rather than its normal bias of reducing noise.</P>
			</doc>
			<example funcBody="int example_func(char *input)" sysIncludes="stdlib.h;string.h">
				<defectiveSrc><![CDATA[
					char buff[_MAX_PATH];

					strncpy(buff, input, _MAX_PATH);  // if strlen(input) > _MAX_PATH,
													 // buff will not be zero-terminated

					return strlen(buff);  // possible crash here
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
					char buff[_MAX_PATH];

					strncpy(buff, input, _MAX_PATH - 1);
					buff[_MAX_PATH - 1] = 0;

					return strlen(buff);  // safe: guaranteed to be zero-terminated
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_53.htm</helpURL>
		</DefectDef>
		<!-- not currently reported
        <DefectDef guid="ae218d69-1895-4cb4-8fae-2c979ac04af1"
            id="212"
            name="UPWARD_GOTO">
            <format>upward goto target '%s'</format>
            <display>upward goto target</display>
        </DefectDef>
-->
		<!-- These should belong to Driver or Defect itself, but they're not getting pulled
             from there into defectdefs.xml properly.
         -->
		<DefectDef guid="5e8caaa1-0662-4d54-99fd-6757430f70bf" id="98101" name="FileSuccess">
			<description>
				<format>
                    File Processed Successfully
                </format>
			</description>
			<doc>
				<P>
					This message indicates that PRE<i>f</i>ast successfully
					processed the indicated file. 
				</P>
			</doc>
			<helpURL>http://anyURL/userguide/warning_98101.htm</helpURL>
		</DefectDef>
		<DefectDef guid="4075ea69-b850-4757-b9d5-28baecd35461" id="98102" name="FileFailure">
			<description>
				<format>
                    Error Processing File
                </format>
			</description>
			<doc>
				<P>
					This message indicates that PRE<i>f</i>ast did not successfully
					process the indicated file.
				</P>
			</doc>
			<helpURL>http://anyURL/userguide/warning_98102.htm</helpURL>
		</DefectDef>
		<!-- 8107 -->
		<!-- (temporary number, probably) -->
		<DefectDef guid="F2A91A3A-F3C1-4432-9F51-92738391081E" id="8107" name="MUST_HOLD">
			<description>
				<format>
                    The resource %variable% must be held when calling 
					this function.
                </format>
				<param name="variable" format="'%ls'"/>
			</description>
			<doc>
				<p>
					This warning indicates that some resource that the program
					must acquire is not held when the failing call is made.
                </p>
				<p>
					This test is used for resources that are usually taken
					and released in the same function.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					ExAcquireResourceLite(resource, true);
					ExReleaseResourceLite(resource);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					KeEnterCriticalRegion();
					ExAcquireResourceLite(resource, true);
					ExReleaseResourceLite(resource);
					KeLeaveCriticalRegion();
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="DB625898-03AC-4176-8001-90360EDE33C1" id="8108" name="PVOID">
			<description>
				<format>
				The argument %variable% is being passed to a function that
				expects a pointer to an object (not a pointer to a pointer)
                </format>
				<param name="variable" format="'%ls'"/>
			</description>
			<additionalInfo>
				<format>
				The function takes a PVOID in this position.
				Usually, this indicates that &amp;pXXX was used when pXXX is
				required
				</format>
			</additionalInfo>
			<doc>
				<p>
				Some 'polymorphic' functions are implemented in C by using
				a PVOID argument to take any pointer type.  However, this
				permits coding a pointer to a pointer when this is not
				intended.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
				    PFAST_MUTEX pFm;
					...
					KeWaitForSingleObject(&pFm, UserRequest, UserMode, false, NULL);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
				    PFAST_MUTEX pFm;
					...
					KeWaitForSingleObject(pFm, UserRequest, UserMode, false, NULL);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8109 -->
		<!-- (temporary number, probably) -->
		<DefectDef guid="0711B3E7-EC19-4616-B3D6-E44A33928250" id="8109" name="MUST_NOT_HOLD">
			<description>
				<format>
                    The resource %variable% cannot be held at the time this
					function is called
                </format>
				<param name="variable" format="'%ls'"/>
			</description>
			<doc>
				<p>
					This warning indicates that some resource that the program
					should not hold at this point is held.  Very possibly it
					is a duplicate acquisition
                </p>
				<p>
					This test is used for resources that are usually taken
					and released in the same function
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					ExAcquireResourceLite(resource, true);
					...
					ExAcquireResourceLite(resource, true);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					ExAcquireResourceLite(resource, true);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8190 -->
		<!-- (temporary number, probably) -->
		<DefectDef guid="0CC57FE6-C9AB-4ab5-A3F2-2DEE657DD19E" id="8190" name="CLOBBERING_RES">
			<description>
				<format>
                    The variable '%variable%' already contains a resource;
					this may cause a leak
                </format>
				<param name="variable" format="'%ls'"/>
			</description>
			<doc>
				<p>
					This warning indicates that a variable containing some
					resource is being changed before releasing the resource
                </p>
				<p>
					This test is used for resources that are usually taken
					and released in the same function
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					x = malloc(100);
					...
					x = malloc(100);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					x = malloc(100);
					...
					free (x);
					...
					x = malloc(100);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8191 -->
		<!-- (temporary number, probably) -->
		<DefectDef guid="4726835E-9C59-4f10-A9B3-F10295246781" id="8191" name="DOUBLE_FREE">
			<description>
				<format>
                    The variable '%variable%' contains no resource, but is
					being released
                </format>
				<param name="variable" format="'%ls'"/>
			</description>
			<doc>
				<p>
					This warning indicates that a variable containing some
					resource is being released without being acquired, or
					after it has been released
                </p>
				<p>
					This test is used for resources that are usually taken
					and released in the same function
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					x = malloc(100);
					...
					free(x);
					...
					free(x);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					x = malloc(100);
					...
					free (x);
					...
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8192 -->
		<!-- (temporary number, probably) -->
		<DefectDef guid="C4FC1BD4-FC11-4f7a-AB33-79E6FF4CA2D9" id="8192" name="MUST_NOT_HOLD_ANY">
			<description>
				<format>
                    No resource of the class %class% can be held when this
					function is called.  %variable% is currently held
                </format>
				<param name="class" format="'%ls'"/>
				<param name="variable" format="'%ls'"/>
			</description>
			<doc>
				<p>
					This indicates that the function being called will
					not operate correctly if any resource of the specific
					class is held at the time it is called
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					KeAcquireSpinLock(lock, &oldIrq);
					...
					IoCompleteRequest(Irp, 0);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					KeAcquireSpinLock(lock, &oldIrq);
					...
					KeReleaseSpinLock(lock, oldIrq);
					...
					IoCompleteRequest(Irp, 0);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
	</DefectDefGroup>
	<DefectDefGroup guid="750EBAA2-3B72-4F3B-8043-23658DF3FCF2" id="8100" name="Drivers">
		<display>Driver Defects</display>
		<doc>
			<P>Defects specific to Windows Device Drivers.</P>
		</doc>
		<ownerURL>http://anyURL</ownerURL>
		<ownerContact>anyAlias</ownerContact>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 8100 -->
		<DefectDef guid="ED94E219-0808-4027-8281-944B18C9EED3" id="8100" name="DRIVER_INFERENCE">
			<description>
				<format>
				The Drivers module has inferred that %prop% has
				been set
				</format>
				<param name="prop" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				This is informational only.  No problem has been detected
				</format>
			</additionalInfo>
			<doc>
				<P>
				This message is generated when the drivers module has
				inferred some property of the function from context.
				It does not indicate an error, but if issues associated
				with the identified property are reported, this may
				be useful in identifying why the issue was reported
				</P>
			</doc>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8101 -->
		<DefectDef guid="6EA4F852-15DB-4d97-99F9-49D4CCFDAC3D" id="8101" name="DRIVER_FUNCTION_TYPE">
			<description>
				<format>
				The Drivers module has inferred that the current function
				is a %prop% function
				</format>
				<param name="prop" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				This is informational only.  No problem has been detected
				</format>
			</additionalInfo>
			<doc>
				<P>
				This message is generated when the drivers module has
				concluded that the function is of the identified type.
				It does not indicate an error, but does indicate that
				PREfast will look for errors specific to that function type.
				If this inference is wrong, unexpected errors can be ignored.
				</P>
				<P>
				The function signature (arguments and result type) are used
				where possible.  Some functions (such as Cancel and StartIo)
				have the same signature, so the name is checked to see if it
				matches the conventional name for that functions.   Other
				functions may be checked for conventional names as well
				</P>
			</doc>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8103-8109 Reserved for 'extended dfa' errors -->
		<!-- 8110 -->
		<DefectDef guid="ef95060a-19ef-4a9d-b6ce-a98aae29e175" id="8110" name="FLOAT_IN_DRIVER">
			<description>
				<format>Drivers must protect floating point hardware state. 
				See use of float %expr%</format>
				<param name="expr" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				Use KeSaveFloatingPointState/KeRestoreFloatingPointState 
				around floating point operations.
				Display Drivers should use the corresponding Eng... routines
				</format>
			</additionalInfo>
			<doc>
				<P>
				Drivers normally run with the floating point
				context of the application that was running most
				recently, and any use of floating point that is
				unprotected by KeSaveFloatingPointState and
				KeRestoreFloatingPointState will change the
				results for some other process, and can often
				cause incorrect or unexpected results in the
				driver.  Any attempt to use a variable or
				constant of a float type will trigger this
				warning because the compiler is free to use the
				floating point hardware should it choose to do
				so
				</P>
				<P>
				Display Drivers should use
				EngSaveFloatingPointState/EngRestoreFloatingPointState
				instead
				</P>
				<P>
				Once an instance of this error is detected along
				any given flow path, as many as possible of any
				subsequent similar errors are suppressed.
				Functions definitions which either take floating
				type arguments or which return a floating type
				do not have this error reported because the
				caller will report the use
				</P>
				<P>
				This test can be mislead when a program saves
				and restores floating point state around a
				function call, and the called function does
				floating point operations 
				</P>
			</doc>
			<example>
				<defectiveSrc><![CDATA[

					void driver_utility()
					{
						float a;
						a += 1;
					}

				]]></defectiveSrc>
				<correctedSrc><![CDATA[

					void driver_utility()
					{
						KFLOATING_SAVE FloatBuf;
						KeSaveFloatingPointState(&FloatBuf);
						float a;
						a += 1;
						KeRestoreFloatingPointState(&FloatBuf);
					}
					
				]]></correctedSrc>
			</example>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8111 -->
		<DefectDef guid="954492EC-28E1-4545-8355-A6F602120BAC" id="8111" name="FP_IRQ_UNMATCHED">
			<description>
				<format>The IRQL where the floating point state was saved
				does not match the current IRQL (for this restore operation)
				</format>
			</description>
			<additionalInfo>
				<format>
				The floating Save/Restore functions require that the IRQL
				be the same at the time of save and the corresponding restore
				</format>
			</additionalInfo>
			<doc>
				<P>
				The IRQL at which the floating point state is saved affects
				how it is saved, and thus the save and restore must occur
				at the same level.
				</P>
			</doc>
			<example>
				<defectiveSrc><![CDATA[

					void driver_utility()
					{
						// Running at APC level
						KFLOATING_SAVE FloatBuf;
						if (KeSaveFloatingPointState(&FloatBuf))
						{
							KeLowerIrql(PASSIVE_LEVEL);
							...
							KeRestoreFloatingPointState(&FloatBuf);
						}
					}

				]]></defectiveSrc>
				<correctedSrc><![CDATA[

					void driver_utility()
					{
						// Running at APC level
						KFLOATING_SAVE FloatBuf;
						if (KeSaveFloatingPointState(&FloatBuf))
						{
							KeLowerIrql(PASSIVE_LEVEL);
							...
							KeRaiseIrql(APC_LEVEL, &old);
							KeRestoreFloatingPointState(&FloatBuf);
						}
					}
					
				]]></correctedSrc>
			</example>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8112 -->
		<DefectDef guid="C5820575-2597-444e-BAE6-16271F91F8AA" id="8112" name="INTERLOCKED_ACCESS">
			<description>
				<format>A variable (%name%) which is accessed via an Interlocked
				function must always be accessed via an Interlocked function
				</format>
				<param name="name" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				It is not always safe to access a variable which is accessed
				via the Interlocked* family of functions in any other way
				</format>
			</additionalInfo>
			<doc>
				<P>
				Although certain ordinary assignments, accesses, and
				comparisons to variables which are used by
				the Interlocked* functions may, upon careful
				analysis, be safe, it is a sufficient risk
				that all such uses are diagnosed.  In
				particular, in a MP system, without using
				the Interlocked functions, there is no
				guarantee that data shared between processors
				will be updated in memory in the order
				expected.  There is also no guarantee that
				accessing the same shared variable twice
				(even in close proximity) without using the
				Interlocked* functions will yield the same
				value (or for that matter a different value,
				even when that is expected).
				</P>
			</doc>
			<example>
				<defectiveSrc><![CDATA[
				inter_var --;
				...
                InterlockedIncrement(&inter_var);
				]]></defectiveSrc>
				<correctedSrc><![CDATA[
				InterlockedDecrement(&inter_var);
				...
                InterlockedIncrement(&inter_var);
				]]></correctedSrc>
			</example>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8113 -->
		<DefectDef guid="35966BBC-DFB7-42b9-9FE7-337FF5DF4A4E" id="8113" name="INTERLOCKED_SCLASS">
			<description>
				<format>Accessing a local variable %name% via an Interlocked function
				</format>
				<param name="name" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				This is an unusual usage which could be reconsidered
				</format>
			</additionalInfo>
			<doc>
				<P>
				Although it is legal to pass the address of a local scope
				variable to another function and then operate on it via the
				Interlocked functions, you need to be sure that the stack
				will not be swapped out unexpectedly and that the variable
				has the correct lifetime across all threads that might use it.
				Unnecessary use of interlocked operations will impact
				performance.
				</P>
				<P>
				Note that the Interlocked* functions all have a return value,
				and often it is the return value that should be used in
				subsequent computations, not any of the input arguments.
				</P>
				<P>
				Note also that the Interlocked* functions only protect their
				leftmost argument; using an Interlocked* function in the
				style of InterlockedExchange(&amp;local, global) does not
				protect the global in any special way, and often serves no
				purpose.  local = InterllockedExchange(&amp;global, global) would 
				have the same effect on the data, and protect the global.
				</P>
			</doc>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8114 -->
		<DefectDef guid="3B1F7612-8E02-4f94-9BFB-1EDE522C0584" id="8114" name="IRP_COPY">
			<description>
				<format>
				Copying a whole IRP leaves certain fields initialized that
				should be cleared or updated
				</format>
			</description>
			<additionalInfo>
				<format>
				Use IoCopyCurrentIrpStackLocationToNext to accomplish this
				</format>
			</additionalInfo>
			<doc>
				<P>
				Improperly copying an IRP can cause serious problems with a
				driver, including lost data and system crashes.  If an
				IRP must be copied and IoCopyCurrentIrpStackLocationToNext
				will not serve, then certain members should not be copied or
				should be zeroed after copying.
				</P>
			</doc>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8120 -->
		<DefectDef guid="6dd060f3-0281-49dd-bf17-6f23ebbd1993" id="8120" name="IRQ_TOO_LOW">
			<description>
				<format>
				The function %func% is not permitted to be called
				at the current IRQ level.  The current level is too low
				</format>
				<param name="func" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				The level might have been inferred from the function signature
				</format>
			</additionalInfo>
			<doc>
				<P>
				The function being called is limited to being called to at
				IRQ levels above the current IRQ level.  Consult the function
				documentation for the acceptable range.
				</P>
				<P>
				Note that PREfast will attempt to infer what it can about
				the current IRQ level, and this warning is generated only
				when it has inferred enough about the IRQ level to detect
				the error.  Inference may come from the signature of the
				function being analyzed or prior calls along the current
				path.
				</P>
				<P>
				Note that if PREfast has not inferred enough about the
				function to determine the IRQ level at which it is running,
				no error will be reported, although a problem may be present.
				</P>
			</doc>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8121 -->
		<DefectDef guid="2b948934-de4a-4a20-b42f-ec04f4019551" id="8121" name="IRQ_TOO_HIGH">
			<description>
				<format>
				The function %func% is not permitted to be called
				at the current IRQ level.  The current level is too high
				</format>
				<param name="func" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				The level might have been inferred from the function signature
				</format>
			</additionalInfo>
			<doc>
				<P>
				The function being called is limited to being called to at
				IRQ levels below the current IRQ level.  Consult the function
				documentation for the acceptable range.
				</P>
				<P>
				Note that PREfast will attempt to infer what it can about
				the current IRQ level, and this warning is generated only
				when it has inferred enough about the IRQ level to detect
				the error.  Inference may come from the signature of the
				function being analyzed or prior calls along the current
				path.
				</P>
				<P>
				Note that if PREfast has not inferred enough about the
				function to determine the IRQ level at which it is running,
				no error will be reported, although a problem may be present.
				</P>
			</doc>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8122 -->
		<DefectDef guid="71469508-c5b2-48da-8c11-71cb4c243c08" id="8122" name="INFERRED_IRQ_TOO_LOW">
			<description>
				<format>
				The function %func% is not permitted to be called at a low
				IRQ level.  Prior function calls are inconsistent with this
				constraint
				</format>
				<param name="func" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				It may be that the error is actually in some prior call
				that limited the range
				</format>
			</additionalInfo>
			<doc>
				<P>
				The function being called is limited to being called at
				high IRQ levels.  However, PREfast has inferred from prior
				calls that the highest acceptable IRQ level for those prior
				calls to succeed is below the minimum for this call.
				Consult the function documentation for the acceptable range.
				</P>
				<P>
				Note that PREfast will attempt to infer what it can about
				the current IRQ level, and this warning is generated only
				when it has inferred enough about the IRQ level to detect
				the error.  Inference may come from the signature of the
				function being analyzed or prior calls along the current
				path.
				</P>
			</doc>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8123 -->
		<DefectDef guid="1f2b9b31-fb4c-4db6-8972-1dd840b09e9b" id="8123" name="INFERRED_IRQ_TOO_HIGH">
			<description>
				<format>
				The function %func% is not permitted to be called at a high
				IRQ level.  Prior function calls are inconsistent with this
				constraint
				</format>
				<param name="func" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				It may be that the error is actually in some prior call
				that limited the range
				</format>
			</additionalInfo>
			<doc>
				<P>
				The function being called is limited to being called at
				low IRQ levels.  However, PREfast has inferred from prior
				calls that the lowest acceptable IRQ level for those prior
				calls to succeed exceeds the maximum for this call.
				Consult the function documentation for the acceptable range.
				</P>
				<P>
				Note that PREfast will attempt to infer what it can about
				the current IRQ level, and this warning is generated only
				when it has inferred enough about the IRQ level to detect
				the error.  Inference may come from the signature of the
				function being analyzed or prior calls along the current
				path.
				</P>
			</doc>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8124 -->
		<DefectDef guid="C983B2AF-7A5D-4e6d-94FF-509886203F35" id="8124" name="IRQ_SET_TOO_LOW">
			<description>
				<format>
				The function %func% causes the IRQ Level to be set below
				the minimum acceptable for the function
				</format>
				<param name="func" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				The level limits were inferred from the function signature
				</format>
			</additionalInfo>
			<doc>
				<P>
				The function being called changes the IRQL to below the
				minimum for the function type (DPC or ISR).  PREfast has
				used the function signature to identify the function as
				an DPC or ISR function.  If it has identified the function
				incorrectly, this error can be ignored.
				</P>
			</doc>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8125 -->
		<DefectDef guid="38EFBA32-DA95-467e-8FBF-78AF107BC372" id="8125" name="PROBE_NO_TRY">
			<description>
				<format>
                    This function must be called from within a try/except block
                </format>
			</description>
			<doc>
				<p>
					This functiom must be called from within a try/except block
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					ProbeForRead(addr, len, 4);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					__try
					{
						ProbeForRead(addr, len, 4);
					}
					__except(EXCEPTION_EXECUTE_HANDLER)
					{
						Status = GetExceptionCode();
						... report error status
					}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8126 -->
		<DefectDef guid="C8560017-C408-4575-A986-7211FDD336C9" id="8126" name="OBJ_REFERENCE_MODE">
			<description>
				<format>
                    The AccessMode parameter to ObReferenceObject* should be IRP-&gt;RequestorMode.
                </format>
			</description>
			<doc>
				<p>
				A driver should use Irp-&gt;RequestorMode rather than specifying 
				UserMode or KernelMode.  This allows kernel-mode IRP senders
				to supply kernel-mode handles safely.
                </p>
			</doc>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8127 -->
		<DefectDef guid="08C0ED21-36C3-4340-BCE2-8B7FE48A5510" id="8127" name="PROTOTYPE_MISMATCH">
			<description>
				<format>
					The function being used as a %func% routine does not
					exactly match the type expected.  Have '%type1%', 
					expecting '%type2%'
                </format>
				<param name="func" format="%ls"/>
				<param name="type1" format="%ls"/>
				<param name="type2" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				It is likely that the difference is that the actual function
				returns a value, and the expected function type is void
				</format>
			</additionalInfo>
			<doc>
				<p>
				To assure that PREfast is able to check the various callbacks,
				a warning about this otherwise benign type mismatch is 
				generated.  The type should match exactly.  Note that any
				return value will be ignored when the expected function
				return type is void, so providing one serves no purpose
                </p>
			</doc>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8128 -->
		<DefectDef guid="8B1CF304-6062-4d89-B46D-B2E5FC2D0A02" id="8128" name="FUNCTION_ASSIGNMENT">
			<description>
				<format>
					An access to %field% has been made directly.
					It should be made by %routine%
                </format>
				<param name="field" format="%ls"/>
				<param name="routine" format="%ls"/>
			</description>
			<doc>
				<p>
				Certain structure members should not be accessed directly,
				but rather through specialized functions
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					irp->CancelRoutine = myCancelRoutine;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					oldCancel = IoSetCancelRoutine(irp, myCancelRoutine);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8129 -->
		<DefectDef guid="B1FD9A31-EE20-4946-B5E5-B2489809B930" id="8129" name="MUST_BE_BITOP">
			<description>
				<format>
					An assignment has been made to %operand% which should
					only be modified using bit sets and clears
                </format>
				<param name="operand" format="%ls"/>
			</description>
			<doc>
				<p>
				The operand is a collection of bit flags, and not preserving 
				the bits other than those explicitly being changed may 
				cause unexpected behaviors.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					fdo->Flags = DO_BUFFERED_IO;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					fdo->Flags |= DO_BUFFERED_IO;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8130 -->
		<DefectDef guid="ED6804FD-9466-4b59-BCED-F6E6E00DE045" id="8130" name="DRIVERS_LEAK">
			<description>
				<format>
					Drivers Module Detected Leak in %operand%
                </format>
				<param name="operand" format="%ls"/>
			</description>
			<doc>
				<p>
				The operand is a collection of bit flags, and not preserving 
				the bits other than those explicitly being changed may 
				cause unexpected behaviors.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					fdo->Flags = DO_BUFFERED_IO;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					fdo->Flags |= DO_BUFFERED_IO;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8131 -->
		<DefectDef guid="8F2CE864-BF61-4f85-BD16-343D485554F8" id="8131" name="NOT_COPYING_NAME">
			<description>
				<format>
					The DriverEntry routine should save a copy of the argument
					%argname%, not the pointer, since the I/O Manager frees 
					the buffer after DriverEntry returns
                </format>
				<param name="argname" format="%ls"/>
			</description>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8132 -->
		<DefectDef guid="E955F7AE-DF57-4306-A3FF-34A12A20A38B" id="8132" name="SIZEOF_POINTER">
			<description>
				<format>
					Taking the size of pointer %operand%
                </format>
				<param name="operand" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
					<p>
				This will yield the size of a pointer (4 or 8), not the size
				of the object pointed to.  Dereference the pointer, or if the
				size of a pointer was intended, use the pointer type or
				(void *) instead
                </p>
				</format>
			</additionalInfo>
			<doc>
				<p>
				Even when sizeof(pointer) is intended, it can be confusing
				to a future reader, so making it explicit that the pointer type
				was intended will both suppress the error and help readers.
				</p>
				<p>
				Should the va_start macro change, this test will produce
				false positives for it.  The PREfast drivers module should 
				be updated to recognize and ignore va_start.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					memset(b, 0, sizeof(b));
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					memset(b, 0, sizeof(*b));
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8133 -->
		<DefectDef guid="AEA1165B-680C-4d28-B49B-309F22023C54" id="8133" name="INITIALIZE_TIMER">
			<description>
				<format>
					IoInitializeTimer is best called from AddDevice
                </format>
			</description>
			<additionalInfo>
				<format>
					<p>
				IoInitializeTimer can only be called once per device object.
				Calling it from the AddDevice routine helps assure that it is
				not unexpectedly called more than once
                </p>
				</format>
			</additionalInfo>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8134 -->
		<DefectDef guid="8CA20881-A507-4c7c-822A-75EB28694FD7" id="8134" name="POOL_TAG">
			<description>
				<format>
					The type of a pool tag should be integral, not a string 
					or string pointer
                </format>
			</description>
			<additionalInfo>
				<format>
					<p>
				A pool tag name should be a character literal using single
				quotes ('gaT_'), not a string in double quotes.  It is normally
				in reverse byte order
                </p>
				</format>
			</additionalInfo>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					p = ExAllocatePoolWithTag(NonPagedPool, 30, "_Tag");
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					p = ExAllocatePoolWithTag(NonPagedPool, 30, 'gaT_');
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8135 -->
		<DefectDef guid="94507315-FCBD-4b36-9FCD-B1AB5718BAF8" id="8135" name="KE_WAIT_LOCAL">
			<description>
				<format>
					If the first argument to KeWaitForSingleObject is
					a local variable, the Mode parameter must be KernelMode
                </format>
			</description>
			<doc>
				<p>
				A wait which is not in kernel mode could cause the process
				to be swapped out.  If the object being awaited is on the
				stack (and thus swapped out) a system crash can result
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					KeWaitForSingleObject(&MyMutex, UserRequest, UserMode, false, NULL);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					KeWaitForSingleObject(&MyMutex, UserRequest, KernelMode, false, NULL);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8136 -->
		<DefectDef guid="A9888677-7023-4131-BFC3-893A5C3DE188" id="8136" name="PO_IRP_ALWAYS_NULL">
			<description>
				<format>
					The last (PIRP) argument to PoRequestPowerIrp should
					always be NULL.  It is '%operand%'
                </format>
				<param name="operand" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
					<p>
					The IRP might be completed before the function call 
					returns, and the value will contain a pointer to 
					discarded memory. See the documentation for details
                </p>
				</format>
			</additionalInfo>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8137 -->
		<DefectDef guid="66BDB610-783B-4c69-81DD-A2700598F317" id="8137" name="ALWAYS_CONSTANT">
			<description>
				<format>
					The variable argument '%operand%' should instead be a constant
                </format>
				<param name="operand" format="%ls"/>
			</description>
			<doc>
				<p>
				The function being called expects that a constant is present
				in the specified position.  The individual function 
				documentation will indicate why a variable in this position
				is unsafe
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					ExAcquireResourceExclusiveLite(Resource, Wait);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					ExAcquireResourceExclusiveLite(Resource, TRUE);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8138 -->
		<DefectDef guid="106F7930-601F-4c16-ABE8-AEC4F14DD168" id="8138" name="NEVER_CONSTANT">
			<description>
				<format>
					The constant argument '%operand%' should instead be variable
                </format>
				<param name="operand" format="%ls"/>
			</description>
			<doc>
				<p>
				The function being called expects that a variable or
				non-constant expression is present
				in the specified position.  The individual function 
				documentation will indicate why a constant in this position
				is unsafe.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					READ_PORT_UCHAR(0x80001234);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					READ_PORT_UCHAR(PortAddress);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8139 -->
		<DefectDef guid="F535FE39-3DD2-452e-B72A-ABA28C4CC9C8" id="8139" name="STRICT_TYPE_MATCH">
			<description>
				<format>
					The argument '%operand%' should exactly match the 
					type '%typename%'
                </format>
				<param name="operand" format="%ls"/>
				<param name="typename" format="%ls"/>
			</description>
			<additionalInfo>
				<format>
				Some functions permit limited arithmetic on the argument
				type, others do not.
				This usually indicates that an enum formal was not passed
				a member of the enum, but may be used for other types as
				well
				</format>
			</additionalInfo>
			<doc>
				<p>
				Since C permits enums to be used interchangably, and
				interchangably with constants, it is easy to pass the
				wrong enum value to a function without an error.
				</p>
				<p>
				Some functions are coded so that only enums are
				allowed.  Others permit the ?: operator to select between
				values of that type.  In some cases, arithmetic on members
				of the enum type is permitted (as would be the case for
				bit flags encoded as an enum) and in a few cases enums and
				constants may be combined.  The documentation will state the
				rules for a specific function.  If a constant is strictly
				required, rule 8137 will also apply.
                </p>
				<p>
				This rule can be used for other parameter types as well; 
				see the function documentation for why the types must match 
				exactly.
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					KeWaitForSingleObject(&MyMutex, UserRequest, UserRequest, false, NULL);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					KeWaitForSingleObject(&MyMutex, UserRequest, UserMode, false, NULL);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  Not yet implemented -->
		<!-- 8140 -->
		<DefectDef guid="98B4D6E2-A6B6-4fc3-9795-73FA28BA3CED" id="8140" name="CRITICAL_OR_IRQ">
			<description>
				<format>
                    This call must occur inside a critical region or the IRQL
					must be at least APC level
                </format>
			</description>
			<doc>
				<p>
					This function must be protected from possible APC calls
					by either using it in a critical region or with the
					IRQL raised to at least APC level
                </p>
			</doc>
			<example funcBody="void Dfa_%id%">
				<defectiveSrc><![CDATA[
					ExAcquireFastMutexUnsafe(Mutex);
					ExReleaseFastMutexUnsafe(Mutex);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
					KeEnterCriticalRegion();
					ExAcquireFastMutexUnsafe(Mutex);
					ExReleaseFastMutexUnsafe(Mutex);
					KeLeaveCriticalRegion();
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- 8141 -->
		<DefectDef guid="C311F394-7617-43ea-B4D1-FFFC38CF0713" id="8141" name="IRQ_LOWERED_IMPROPERLY">
			<description>
				<format>
				The argument %expr% causes the IRQ Level to be set below
				the current IRQL, and this function cannot be used for
				that purpose
				</format>
				<param name="expr" format="%ls"/>
			</description>
			<doc>
				<P>
				The function being called changes the IRQL to below the
				current IRQL, and the function is not intended for that 
				purpose.
				</P>
			</doc>
			<example>
				<defectiveSrc><![CDATA[

				KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
				KeRaiseIrql(PASSIVE_LEVEL, &OldIrql);

				]]></defectiveSrc>
				<correctedSrc><![CDATA[

				KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
				KeLowerIrql(OldIrql);

				]]></correctedSrc>
			</example>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8142 -->
		<DefectDef guid="95A795EF-F1CA-47f9-A144-8D421FEA10B3" id="8142" name="RELEASE_CONSTANT">
			<description>
				<format>
				The argument %expr% is a constant and is being passed
				in a context where a resource release or other restoration
				of a prior state is being made.  An object containing
				a resource should be passed
				</format>
				<param name="expr" format="%ls"/>
			</description>
			<doc>
				<P>
				This is most commonly found when passing a constant to
				a function such as KeRestoreIrql, which should instead
				be passed a value containing a previously saved IRQL.
				</P>
			</doc>
			<example>
				<defectiveSrc><![CDATA[

				KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
				KeLowerIrql(PASSIVE_LEVEL);

				]]></defectiveSrc>
				<correctedSrc><![CDATA[

				KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
				KeLowerIrql(OldIrql);

				]]></correctedSrc>
			</example>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8143 -->
		<DefectDef guid="DCFEAE0A-F569-4c17-9E66-50250790DBE0" id="8143" name="PENDING_STATUS_ERROR">
			<description>
				<format>
				A dispatch routine that calls IoMarkIrpPending 
				must also return STATUS_PENDING
				</format>
			</description>
			<example>
				<defectiveSrc><![CDATA[

				IoMarkIrpPending(Irp);
				...
				return STATUS_SUCCESS;

				]]></defectiveSrc>

				IoMarkIrpPending(Irp);
				...
				return STATUS_PENDING;

				<correctedSrc><![CDATA[


				]]></correctedSrc>
			</example>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8144 -->
		<DefectDef guid="319E2C38-3F65-4ac4-BB84-A3C16473EDC9" id="8144" name="CANCEL_IRQL_FROM_IRP">
			<description>
				<format>
				Within a cancel routine, at the point of exit,
				the IRQL found Irp-&gt;CancelIrql should be the current IRQL.
				</format>
			</description>
			<additionalInfo>
				<format>
				The value need not be restored by any specific function,
				but must be restored before exit.  PREfast was unable
				to determine that it was restored to the required value.
				</format>
			</additionalInfo>
			<example>
				<defectiveSrc><![CDATA[

				IoReleaseCancelSpinLock(PASSIVE_LEVEL);

				]]></defectiveSrc>
				<correctedSrc><![CDATA[

				IoReleaseCancelSpinLock(Irp->CancelIrql);

				]]></correctedSrc>
			</example>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8145 -->
		<DefectDef guid="83BC3377-6947-43f4-9FF7-B48636400C0C" id="8145" name="MODIFYING_MDL">
			<description>
				<format>
				The opaque MDL structure should not be modified by a driver
				</format>
			</description>
			<doc>
				<P>
				The MdlFlags field is used as a proxy for all MDL fields.
				With the exception of MDL_MAPPING_CAN_FAIL for drivers that
				need to be Win98 compatible, no fields should be modified.
				</P>
			</doc>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- 8146 -->
		<DefectDef guid="6AC43B16-9749-453e-A403-ECBFE7093784" id="8146" name="STRSAFE_H">
			<description>
				<format>
				Kernel Mode drivers should use ntstrsafe.h, not strsafe.h
				</format>
			</description>
			<additionalInfo>
				<format>
				The header ntstrsafe.h contains versions of the functions 
				found in strsafe.h that are suitable for use in kernel
				mode code
				</format>
			</additionalInfo>
			<helpURL>http://put_a_link_to_your_warning_documentation_site_here</helpURL>
		</DefectDef>
		<!-- -->
		<!-- 8190-8199 Reserved for 'extended dfa' errors -->
	</DefectDefGroup>
	<DefectDefGroup guid="05aca904-daee-4014-a0f8-c24e2570d775" id="213" name="Hresult">
		<doc>
			<p>
				<code>HRESULT</code> is a return status used by COM
                functions to signal success or failure.  There are strict
                guidelines for how <code>HRESULT</code> should be used;
                however, these are frequently overlooked or ignored.
            </p>
			<p>
                PRE<i>f</i>ast detects situations where <code>HRESULT</code>
                has either been used incorrectly, or has been used in a
                manner that may cause undesirable results.
            </p>
		</doc>
		<ownerURL>http://anyURL</ownerURL>
		<ownerContact>anyAlias</ownerContact>
		<!-- -->
		<DefectDef guid="610c0db8-00e5-477c-991f-a49bab43252d" id="214" name="CAST_HRESULT_TO_BOOL">
			<description>
				<format>
                    Cast between semantically different integer types
                </format>
			</description>
			<additionalInfo>
				<format>
                    HRESULT to Boolean
                </format>
			</additionalInfo>
			<doc>
				<p>
					<b>Note</b>:  for the purpose of this warning, the
                    <code>SCODE</code> type is equivalent to
                    <code>HRESULT</code>.
                </p>
				<p>
                    This warning indicates that an <code>HRESULT</code> is
                    being explicitly cast to a Boolean type.  This is likely
                    to give undesirable results.  For example, the typical
                    success value for <code>HRESULT</code>,
                    <code>S_OK</code>, is <code>false</code> when tested as
                    a Boolean.
                </p>
				<p>
                    In most cases, the <code>SUCCEEDED</code> or
                    <code>FAILED</code> macro should be used to test the
                    value of an <code>HRESULT</code>.
                </p>
				<p>
                    In some cases, the program may be attempting to reuse a
                    Boolean local variable to store <code>HRESULT</code>s as
                    well.  This practice is often error-prone; it is much
                    safer (and likely more efficient) to use a separate
                    <code>HRESULT</code> variable.
                </p>
			</doc>
			<example funcBody="BOOL Hresult_214" sysIncludes="objbase.h">
				<defectiveSrc><![CDATA[
                    HRESULT hr;
                    LPMALLOC pMalloc;

                    hr = CoGetMalloc(1, &pMalloc);

                    if (FAILED(hr)) {
                        return ((BOOL)hr);
                    }

                    /* ... */

                    return hr;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    HRESULT hr;
                    LPMALLOC pMalloc;

                    hr = CoGetMalloc(1, &pMalloc);

                    if (FAILED(hr)) {
                        return FALSE;
                    }

                    /* ... */

                    return TRUE;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_214.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="4434aa13-5995-447e-9a89-469602d5ff01" id="215" name="CAST_BOOL_TO_HRESULT">
			<description>
				<format>
                    Cast between semantically different integer types
                </format>
			</description>
			<additionalInfo>
				<format>
                    Boolean to HRESULT
                </format>
			</additionalInfo>
			<doc>
				<p>
					<b>Note</b>:  for the purpose of this warning, the
                    <code>SCODE</code> type is equivalent to
                    <code>HRESULT</code>.
                </p>
				<p>
                    This warning indicates that a Boolean is being cast to
                    an <code>HRESULT</code>.  This is likely to give
                    undesirable results.  For example, the typical failure
                    value for functions that return a Boolean
                    (<code>false</code>) is a success status when tested as
                    an <code>HRESULT</code>.

                </p>
				<p>
                    This error frequently occurs when a Boolean is used as
                    an argument to the <code>SUCCEEDED</code> or
                    <code>FAILED</code> macros, which explicitly cast their
                    argument to an <code>HRESULT</code>.  In general, the
                    <code>SUCCEEDED</code> and <code>FAILED</code> macros
                    should only be applied to <code>HRESULT</code>s.
                </p>
			</doc>
			<example funcBody="int Hresult_215" sysIncludes="windows.h" globalDecls="extern BOOL SomeFunction(void)">
				<defectiveSrc><![CDATA[
                    if (SUCCEEDED(SomeFunction())) {
                        return 0;
                    } else {
                        return -1;
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (SomeFunction() == TRUE) {
                        return 0;
                    } else {
                        return -1;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_215.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="abc1514b-c8a4-49e4-b3f8-b8a162bac668" id="216" name="COMPILER_INSERTED_CAST_BOOL_TO_HRESULT">
			<description>
				<format>
                    Compiler-inserted cast between semantically different integer types
                </format>
			</description>
			<additionalInfo>
				<format>
                    Boolean to HRESULT
                </format>
			</additionalInfo>
			<doc>
				<p>
					<b>Note</b>:  for the purpose of this warning, the
                    <code>SCODE</code> type is equivalent to
                    <code>HRESULT</code>.
                </p>
				<p>
                    This warning indicates that a Boolean is being used as
                    an <code>HRESULT</code> without being explicitly cast.
                    This is likely to give undesirable results.  For
                    instance, the typical failure value for functions that
                    return a Boolean (<code>false</code>) is a success
                    status when tested as an <code>HRESULT</code>.
                </p>
			</doc>
			<example funcBody="HRESULT Hresult_216" sysIncludes="windows.h" globalDecls="extern bool SomeFunction(void)">
				<defectiveSrc><![CDATA[
                    return SomeFunction();
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (SomeFunction() == true) {
                        return S_OK;
                    } else {
                        return E_FAIL;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_216.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="f05e16d0-5fb9-4122-9006-e1c9d2a64852" id="217" name="TESTING_HRESULT_WITH_NOT">
			<description>
				<format>
                    Implicit cast between semantically different integer
                    types
                </format>
			</description>
			<additionalInfo>
				<format>
                    testing HRESULT with 'not'
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Consider using SUCCEEDED or FAILED macro instead
                </format>
			</recommendedFix>
			<doc>
				<p>
					<b>Note</b>:  for the purpose of this warning, the
                    <code>SCODE</code> type is equivalent to
                    <code>HRESULT</code>.
                </p>
				<p>
                    This warning indicates that an <code>HRESULT</code> is
                    being tested with the C not (<code>!</code>) operator.
                    This is almost certain to give undesirable results.  The
                    typical success value for <code>HRESULT</code>
                    (<code>S_OK</code>) is <code>FALSE</code> when tested as
                    a Boolean.
                </p>
				<p>
                    If the actual intent is to see whether the
                    <code>HRESULT</code> indicates success, use the
                    <code>SUCCEEDED</code> macro instead.  If the actual
                    intent is to check specifically for the <code>S_OK</code>
					<code>HRESULT</code> (i.e., ignoring other possible
                    success values), then an explicit comparison to
                    <code>S_OK</code> should be used.
                </p>
			</doc>
			<example funcBody="int Hresult_217" sysIncludes="windows.h" globalDecls="extern HRESULT SomeFunction(void)">
				<defectiveSrc><![CDATA[
                    HRESULT hr;

                    hr = SomeFunction();

                    if (!hr) {
                        return 1;
                    } else {
                        return -1;
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    HRESULT hr;

                    hr = SomeFunction();

                    if (hr == S_OK) {
                        return 1;
                    } else {
                        return -1;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_217.htm</helpURL>
		</DefectDef>
		<!-- -->
		<!-- Not in 1.0

        <DefectDef guid="7ddba7e6-aae2-421b-932a-70eb8cac4d48"
            id="218"
            name="COMPARING_HRESULT_TO_ZERO">
            <format>Comparing HRESULT to 0 or FALSE; use SUCCEEDED or FAILED macro instead</format>
        </DefectDef>
-->
		<!-- -->
		<DefectDef guid="5b71ee07-255d-4540-a087-1f2094e2f633" id="219" name="COMPARING_HRESULT_TO_ONE">
			<description>
				<format>
                    Implicit cast between semantically different integer
                    types
                </format>
			</description>
			<additionalInfo>
				<format>
                    comparing HRESULT to 1 or TRUE
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Consider using SUCCEEDED or FAILED macro instead
                </format>
			</recommendedFix>
			<doc>
				<p>
					<b>Note</b>:  for the purpose of this warning, the
                    <code>SCODE</code> type is equivalent to
                    <code>HRESULT</code>.
                </p>
				<p>
                    This warning indicates that an <code>HRESULT</code> is
                    being compared against an explicit,
                    non-<code>HRESULT</code> value of one (1).  This is
                    likely to give undesirable results.  The typical success
                    value for <code>HRESULT</code> (<code>S_OK</code>) is
                    not equal to <code>TRUE</code>.
                </p>
				<p>
                    In most cases, this warning is caused by the code
                    mistakenly treating an <code>HRESULT</code> as a
                    Boolean.  It is best to use the <code>SUCCEEDED</code>
                    or <code>FAILED</code> macros to test the value of an
                    <code>HRESULT</code>.
                </p>
			</doc>
			<example funcBody="HRESULT Hresult_219" sysIncludes="windows.h" globalDecls="extern HRESULT SomeFunction(void)">
				<defectiveSrc><![CDATA[
                    if (SomeFunction() == TRUE) {
                        return S_OK;
                    }

                    return E_FAIL;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (SUCCEEDED(SomeFunction())) {
                        return S_OK;
                    }

                    return E_FAIL;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_219.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="d76eec24-9580-4bf0-8e8c-e34d777de8a0" id="220" name="COMPARING_HRESULT_TO_MINUS_ONE">
			<description>
				<format>
                    Implicit cast between semantically different integer
                    types
                </format>
			</description>
			<additionalInfo>
				<format>
                    comparing HRESULT to -1
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Consider using SUCCEEDED or FAILED macro instead
                </format>
			</recommendedFix>
			<doc>
				<p>
					<b>Note</b>:  for the purpose of this warning, the
                    <code>SCODE</code> type is equivalent to
                    <code>HRESULT</code>.
                </p>
				<p>
                    This warning indicates that an <code>HRESULT</code> is
                    being compared against an explicit,
                    non-<code>HRESULT</code> value of -1, which is not a
                    well-formed <code>HRESULT</code>.
                </p>
				<p>
                    It is best to use the <code>SUCCEEDED</code> or
                    <code>FAILED</code> macro to test the value of an
                    <code>HRESULT</code>. 
                </p>
				<p>
                    In most cases, this warning is caused by the code
                    mistakenly expecting that a function that actually
                    returns an <code>HRESULT</code> instead returns an integer
                    (using -1 as a failure value).  If the actual intent to
                    check specifically for the <code>E_FAIL HRESULT</code>
                    (i.e., ignoring other possible failure values), then an
                    explicit comparison to <code>E_FAIL</code> is appropriate.
                    Otherwise, use the <code>SUCCEEDED</code> or
                    <code>FAILED</code> macros.
                </p>
			</doc>
			<example funcBody="HRESULT Hresult_220" sysIncludes="windows.h" globalDecls="extern HRESULT SomeFunction(void)">
				<defectiveSrc><![CDATA[
                    if (SomeFunction() == -1) {
                        return E_FAIL;
                    }

                    return S_OK;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (FAILED(SomeFunction())) {
                        return E_FAIL;
                    }

                    return S_OK;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_220.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="907b03b7-a3de-47d4-b3b7-95fae397da64" id="221" name="COMPARING_HRESULT_TO_INT">
			<description>
				<format>
                    Implicit cast between semantically different integer
                    types
                </format>
			</description>
			<additionalInfo>
				<format>
                    comparing HRESULT to an integer
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Consider using SUCCEEDED or FAILED macros instead
                </format>
			</recommendedFix>
			<doc>
				<p>
					<b>Note</b>:  for the purpose of this warning, the
                    <code>SCODE</code> type is equivalent to
                    <code>HRESULT</code>.
                </p>
				<p>
                    This warning indicates that an <code>HRESULT</code> is
                    being compared against an integer.  This may reflect
                    some confusion about <code>HRESULT</code> behavior.
                </p>
				<p>
                    This warning is often caused by the code mistakenly
                    expecting that a function returns an integer when it
                    actually returns an <code>HRESULT</code>.
                </p>
				<p>
                    It is also worth noting that some values that are
                    intended to function as <code>HRESULT</code>s are not
                    actually typed that way.
                </p>
			</doc>
			<example funcBody="HRESULT Hresult_221" sysIncludes="windows.h" globalDecls="extern HRESULT SomeFunction(void)">
				<defectiveSrc><![CDATA[
                    if (SomeFunction() == 4) {
                        return S_FALSE;
                    }

                    return S_OK;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (SUCCEEDED(SomeFunction())) {
                        return S_FALSE;
                    }

                    return S_OK;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_221.htm</helpURL>
		</DefectDef>
		<!-- -->
		<!-- Not in 1.0
        <DefectDef guid="9e27983c-24ca-4170-935c-fcd0441dc98e"
            id="222"
            name="COMPARING_HRESULT_TO_S_OK">
            <format>Comparing HRESULT to S_OK; use SUCCEEDED or FAILED macros instead</format>
        </DefectDef>
-->
		<!-- -->
		<!-- Not in 1.0
        <DefectDef guid="d8f896ad-4bd7-44b1-ae66-addcebc35671"
            id="223"
            name="COMPARING_HRESULT_TO_E_FAIL">
            <format>Comparing HRESULT to E_FAIL; use SUCCEEDED or FAILED macros instead</format>
        </DefectDef>
-->
		<!-- -->
		<!-- Not in 1.0
        <DefectDef guid="906bad58-7278-41c5-8d8c-77e7ac257325"
            id="224"
            name="ASSIGNING_ZERO_TO_HRESULT">
            <format>Assigning 0 or FALSE to HRESULT; use S_OK instead</format>
        </DefectDef>
-->
		<!-- -->
		<DefectDef guid="dbc662b8-1d37-4afb-8c46-78a6e5b93ac0" id="225" name="ASSIGNING_ONE_TO_HRESULT">
			<description>
				<format>
                    Implicit cast between semantically different integer
                    types
                </format>
			</description>
			<additionalInfo>
				<format>
                    assigning 1 or TRUE to HRESULT
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Consider using S_FALSE instead
                </format>
			</recommendedFix>
			<doc>
				<p>
					<b>Note</b>:  for the purpose of this warning, the
                    <code>SCODE</code> type is equivalent to
                    <code>HRESULT</code>.
                </p>
				<p>
                    This warning indicates that an <code>HRESULT</code> is
                    being assigned or initialized with a value of an
                    explicit, non-<code>HRESULT</code> 1.  This warning is
                    often caused by accidental confusion of Boolean and
                    <code>HRESULT</code> types.
                </p>
				<p>
                    To indicate success, the symbolic constant
                    <code>S_OK</code> should be used.
                </p>
				<p>
                    To indicate failure, some E_constant should be used.
                </p>
			</doc>
			<example funcBody="HRESULT Hresult_225" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    HRESULT hr = TRUE;

                    return hr;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    HRESULT hr = S_OK;

                    return hr;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_225.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="e3ad0378-2ca6-433a-8efe-90c156ba137c" id="226" name="ASSIGNING_MINUS_ONE_TO_HRESULT">
			<description>
				<format>
                    Implicit cast between semantically different integer
                    types
                </format>
			</description>
			<additionalInfo>
				<format>
                    assigning -1 to HRESULT
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Consider using E_FAIL instead
                </format>
			</recommendedFix>
			<doc>
				<p>
					<b>Note</b>:  for the purpose of this warning, the
                    <code>SCODE</code> type is equivalent to
                    <code>HRESULT</code>.
                </p>
				<p>
                    This warning indicates that an <code>HRESULT</code> is
                    being assigned or initialized with a value of an
                    explicit, non-<code>HRESULT</code> -1; this is not a
                    well-defined <code>HRESULT</code>.  This warning is
                    often caused by accidental confusion of integers and
                    <code>HRESULT</code>s.
                </p>
				<p>
                    To assign success, the symbolic constant
                    <code>S_OK</code> should be used.
                </p>
				<p>
                    To assign failure, some E_constant should be used.
                </p>
			</doc>
			<example funcBody="HRESULT Hresult_226" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    HRESULT hr = -1;

                    return hr;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    HRESULT hr = E_FAIL;

                    return hr;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_226.htm</helpURL>
		</DefectDef>
		<!-- -->
		<!-- Not in 1.0
        <DefectDef guid="2105b696-0889-479a-aa99-0c67ccc30cb3"
            id="227"
            name="ASSIGNING_INT_TO_HRESULT">
            <format>Assigning int to HRESULT; may be confusion of status types</format>
        </DefectDef>
-->
		<!-- -->
		<!-- Not in 1.0
        <DefectDef guid="c9fc298e-07c0-4260-a08d-dec8da481086"
            id="228"
            name="RETURNING_HRESULT_AS_INT">
            <format>Returning HRESULT as an integer; may be confusion of status types</format>
        </DefectDef>
-->
		<!-- -->
		<!-- Not in 1.0
        <DefectDef guid="202f81b0-58d7-4e13-bc67-e26db73d6534"
            id="229"
            name="RETURNING_INT_AS_HRESULT">
            <format>Returning integer as an HRESULT; may be confusion of status types</format>
        </DefectDef>
-->
		<!-- -->
		<DefectDef guid="66885b89-ddf7-4878-b75d-6df1e8433600" id="230" name="USING_HRESULT_IN_BOOLEAN_CONTEXT">
			<description>
				<format>
                    Implicit cast between semantically different integer
                    types
                </format>
			</description>
			<additionalInfo>
				<format>
                    using HRESULT in a Boolean context
                </format>
			</additionalInfo>
			<doc>
				<p>
					<b>Note</b>:  for the purpose of this warning, the
                    <code>SCODE</code> type is equivalent to
                    <code>HRESULT</code>.
                </p>
				<p>
                    This warning indicates that a bare <code>HRESULT</code>
                    is being used in a context (such as the test of an if
                    statement) where a Boolean result is expected.  This is
                    likely to give undesired results.  For instance, the
                    typical success value for <code>HRESULT</code>
                    (<code>S_OK</code>) is <code>FALSE</code> when tested as
                    a Boolean. 
                </p>
				<p>
                    In most situations, the <code>SUCCEEDED</code> or
                    <code>FAILED</code> macro should be used to test the
                    value of <code>HRESULT</code>.
                </p>
			</doc>
			<example funcBody="bool Hresult_230" sysIncludes="windows.h" globalDecls="extern HRESULT GetResult(void)">
				<defectiveSrc><![CDATA[
                    HRESULT hr;

                    hr = GetResult();

                    if (hr) {
                        return false;
                    } else {
                        return true;
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    HRESULT hr;

                    hr = GetResult();

                    if (FAILED(hr)) {
                        return false;
                    } else {
                        return true;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_230.htm</helpURL>
		</DefectDef>
	</DefectDefGroup>
	<DefectDefGroup guid="148b5a12-434a-43aa-9c06-f4ab5dc91ef1" id="400" name="i18n">
		<doc>
			<p>
                PRE<i>f</i>ast detect several errors related to the process
                of localization.
            </p>
		</doc>
		<ownerURL>http://anyURL</ownerURL>
		<ownerContact>anyAlias</ownerContact>
		<!--  -->
		<DefectDef guid="f8f63aa8-e00b-4392-b77e-fe0208b14676" id="400" name="LOCALE_DEPENDENT_CONSTANT_STRING_COMPARISON">
			<description>
				<format>
                    Using %function% to perform a case-insensitive compare
                    to constant string %string%
                </format>
				<param name="function" format="'%ls'"/>
				<param name="string" format="'%ls'"/>
			</description>
			<consequence>
				<format>
                    Yields unexpected results in non-English locales
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that a case-insensitive
                    comparison to a constant string is being performed in a
                    locale-dependent way, when it appears that a
                    locale-independent comparison was intended.
                </p>
				<p>
                    The typical consequence of this defect is incorrect
                    behavior in non-English speaking locales. For example,
                    in Turkish, ".gif" will not match ".GIF"; in Vietnamese,
                    "LogIn" will not match "LOGIN". If not corrected now,
                    these problems will be discovered (and need to be
                    corrected) during localization testing.
                </p>
				<p>
                    String comparisons are performed in two different
                    situations: 
                    <ul>
						<li>
                            In some situations, the comparison should match
                            the user's language preferences; for example,
                            the user speaks French and wants their list of
                            contact names in the default order for French.
                            In this case, a locale-dependent comparison
                            (such as performed by <code>lstrcmpi</code>, or
                            <code>CompareString</code> with the current
                            locale) is appropriate.
                        <li>
							</li>
                            In other situations, the comparison should
                            return the same result regardless of the user's
                            language; for example, does the extension of a
                            file equal ".gif." In this case, a
                            locale-independent comparison is appropriate.
                        </li>
					</ul>
				</p>
				<p>
                    Performing a locale-dependent comparison when a
                    locale-independent comparison was intended is a major
                    source of localization problems for languages such as
                    Turkish.
                </p>
				<p>
                    String comparisons should generally be performed with
                    the <code>CompareString</code> function. To
                    perform a locale-independent comparison on Windows XP,
                    the first parameter should be the constant
                    <code>LOCALE_INVARIANT</code>. For example, to
                    perform a locale-independent test for whether pString
                    matches foo.gif ignoring upper/lower case differences,
                    use a call such as:
                    <pre>
    CompareString(LOCALE_INVARIANT,
                  NORM_IGNORECASE,
                  pString, 
                  -1,
                  TEXT("foo.gif"),
                  -1) == 2</pre>
				</p>
				<p>
                    If code must support down-level operating systems as
                    well, the preferred way of performing a
                    locale-independent test is:  
                    <pre>
    CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH,
                                      SUBLANG_ENGLISH_US),
                           SORT_DEFAULT),
                  ...</pre>
				</p>
				<p>
                    This warning is produced on calls to functions such as 
                    <ul><code>
							<ol>
                            lstrcmpi 
                        </ol>
							<ol>
                            lstrcmpiA 
                        </ol>
							<ol>
                            lstrcmpiW 
                        </ol>
						</code></ul>
				</p>
				<p>
                    Note that this warning is not produced if the constant
                    string is the empty string (<code>TEXT("")</code>) or
                    consists only of digits or punctuation. Even though the
                    behavior will be correct in these cases, it is probably
                    more efficient to use a case-sensitive comparison
                    function.
                </p>
			</doc>
			<example funcBody="int I18n_400(LPCTSTR extension)" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    return (lstrcmpi(extension,
                                     TEXT("gif")) == 0);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    return (CompareString(LOCALE_INVARIANT,
                                          NORM_IGNORECASE, 
                                          extension,
                                          -1,
                                          TEXT("gif"),
                                          -1) == 2);
                ]]></correctedSrc>
				<!-- BUGBUG:  What's the best way to include the correct "downlevel" example ?

    DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, 
                                     SUBLANG_ENGLISH_US),
                          SORT_DEFAULT); 

    return (CompareString(lcid, 
                          NORM_IGNORECASE,
                          extension, 
                          -1, 
                          TEXT("gif"),
                          -1) == 2);
-->
			</example>
			<helpURL>http://anyURL/userguide/warning_400.htm</helpURL>
		</DefectDef>
		<DefectDef guid="6e2b2ffc-0fae-4709-8de4-a848299026ff" id="401" name="DEFAULT_LOCALE_CONSTANT_STRING_COMPARISON">
			<description>
				<format>
                    Using %function% in a default locale to perform
                    a case-insensitive compare to constant string %string%
                </format>
				<param name="function" format="'%ls'"/>
				<param name="string" format="'%ls'"/>
			</description>
			<consequence>
				<format>
                    Yields unexpected results in non-English locales
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that a case-insensitive
                    comparison to a constant string is being performed when
                    specifying the default locale; usually, a
                    locale-independent comparison was intended.
                </p>
				<p>
                    The typical consequence of this defect is incorrect
                    behavior in non-English speaking locales. For example,
                    in Turkish, ".gif" will not match ".GIF"; in Vietnamese,
                    "LogIn" will not match "LOGIN". If not corrected now,
                    these problems will be discovered (and need to be
                    corrected) during localization testing.
                </p>
				<p>
                    String comparisons are performed in two different
                    situations: 
                    <ul>
						<li>
                            In some situations, the comparison should match
                            the user's language preferences; for example,
                            the user speaks French and wants their list of
                            contact names in the default order for French.
                            In this case, a locale-dependent comparison
                            (such as performed by <code>lstrcmpi</code>, or
                            <code>CompareString</code> with the current
                            locale) is appropriate.
                        </li>
						<li>
                            In other situations, the comparison should
                            return the same result regardless of the user's
                            language; for example, does the extension of a
                            file equal ".gif." In this case, a
                            locale-independent comparison is appropriate. 
                        </li>
					</ul>

                    Performing a locale-dependent comparison when a
                    locale-independent comparison was intended is a major
                    source of localization problems for languages such as
                    Turkish.
                </p>
				<p>
                    The <code>CompareString</code> function takes a
                    locale as an argument; however, passing in a default
                    locale (e.g., the constant
                    <code>LOCALE_USER_DEFAULT</code>, or the value
                    returned from a function such as
                    <code>GetThreadLocale</code>) will
                    give different behaviors in different locales depending
                    on the user's default. Usually, case-insensitive
                    comparisons against a constant string should be
                    performed in a locale-independent comparison.
                </p>
				<p>
                    To perform a locale-independent comparison using
                    <code>CompareString</code> on Windows XP, the
                    first parameter should be the constant
                    <code>LOCALE_INVARIANT</code>; for example, to
                    perform a locale-independent test for whether pString
                    matches foo.gif ignoring upper/lower case differences,
                    use a call such as:

                    <pre>
    CompareString(LOCALE_INVARIANT,
                  NORM_IGNORECASE,
                  pString, 
                  -1, 
                  TEXT("foo.gif"), 
                  -1) == 2</pre>
				</p>
				<p>
                    If code must support down-level operating systems as
                    well, the preferred way of performing a
                    locale-independent test is:

                    <pre>
    CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH,
                                      SUBLANG_ENGLISH_US),
                           SORT_DEFAULT),
                  ...</pre>
				</p>
				<p>
                    Note that this warning is not produced if the constant
                    string is the empty string (<code>TEXT("")</code>) or
                    consists only of digits or punctuation. Even though the
                    behavior will be correct in these cases, it is probably
                    more efficient to use a case-sensitive comparison
                    function.
                </p>
				<p>
                    PRE<i>f</i>ast considers the locale to be the default
                    locale if it arises from any of the following constructs:

                    <ul>
						<b><u>Constants</u></b>:


                            <ol>
                                LOCALE_NEUTRAL    (this is a
                                legacy issue-gives the current user's locale
                                instead of neutral)
                            </ol>
						<ol>
                                LOCALE_USER_DEFAULT
                            </ol>
						<ol>
                                LOCALE_SYSTEM_DEFAULT
                            </ol>
						<ol>
                                LANG_USER_DEFAULT
                            </ol>
						<ol>
                                LANG_SYSTEM_DEFAULT
                            </ol>
					</ul>
					<ul>
						<b><u>Functions</u></b>:
                        <ol>
                            GetThreadLocale()
                        </ol>
						<ol>
                            GetUserDefaultLCID()
                        </ol>
						<ol>
                            GetUserDefaultLangID()
                        </ol>
						<ol>
                            GetUserDefaultUILanguage()
                        </ol>
						<ol>
                            GetSystemDefaultLCID()
                        </ol>
						<ol>
                            GetSystemDefaultLangID()
                        </ol>
						<ol>
                            GetSystemDefaultUILanguage()
                        </ol>
					</ul>
				</p>
			</doc>
			<example funcBody="int I18n_401(LPCTSTR extension)" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    return (CompareString(LOCALE_USER_DEFAULT,
                                          NORM_IGNORECASE,
                                          extension, 
                                         -1, 
                                         TEXT("gif"),
                                         -1) == 2);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    return (CompareString(LOCALE_INVARIANT,
                                          NORM_IGNORECASE,
                                          extension,
                                          -1, 
                                          TEXT("gif"),
                                          -1) == 2);
                ]]></correctedSrc>
				<!-- BUGBUG:  What's the best way to include the correct "downlevel" example ?

     DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH,
                                      SUBLANG_ENGLISH_US),
                           SORT_DEFAULT); 

     return (CompareString(lcid, 
                           NORM_IGNORECASE,
                           extension, 
                           -1, 
                           TEXT("gif"), 
                           -1) == 2);
-->
			</example>
			<helpURL>http://anyURL/userguide/warning_401.htm</helpURL>
		</DefectDef>
		<!--  The following are not currently reported.

        <DefectDef guid="B5609246-9250-491b-8C9F-19EED4C17D78"
            id="402"
            name="LOCALE_DEPENDENT_CASE_SENSITIVE_CONSTANT_STRING_COMPARISON">
            <format>Using 'strcmp' to perform a case-sensitive compare to a constant string will give unexpected results in non-English locales</format>
            <display>Using <param>function</param> to perform a case-insensitive compare to a constant string will give unexpected results in non-English locales</display>
        </DefectDef>

        <DefectDef guid="89BA6245-8ACD-4740-96BC-997726FA06C5"
            id="403"
            name="LOCALE_DEPENDENT_CASE_INSENSITIVE_STRING_COMPARISON">
            <format>Using 'lstrcmpi' to perform a case-insensitive compare may give unexpected results in non-English locales</format>
            <display>Using <param>function</param> to perform a case-insensitive compare may give unexpected results in non-English locales</display>
        </DefectDef>

        <DefectDef guid="3DCB210C-7230-4b1c-B0C0-F2B4AF01798A"
            id="404"
            name="DEFAULT_LOCALE_CASE_INSENSITIVE_STRING_COMPARISON">
            <format>Using 'CompareString' in a default locale to perform a case-sensitive compare to constant string will give unexpected results in non-English locales</format>
            <display>Using 'function' in a default locale to perform a case-sensitive compare to constant string will give unexpected results in non-English locales</display>
        </DefectDef>

        <DefectDef guid="F6C2B53D-D385-43c8-8168-375565890BF0"
            id="405"
            name="NON_DEFAULT_LOCALE_CASE_INSENSITIVE_CONSTANT_STRING_COMPARISON">
            <format>Using 'CompareString' in a non-default locale to perform a case-insensitive compare to constant string may give unexpected results in non-English locales</format>
            <display>Using 'function' in a non-default locale to perform a case-insensitive compare to constant string may give unexpected results in non-English locales</display>
        </DefectDef>

        <DefectDef guid="A868E010-4462-4cba-A9AB-713439661AD3"
            id="406"
            name="INEFFICIENT_CASE_INSENSITIVE_COMPARE">
            <format>Using 'lstrcmpi' to perform a case-insensitive compare to a constant string with no letters is inefficient</format>
            <display>Using <param>function</param> to perform a case-insensitive compare to a constant string with no letters is inefficient</display>
        </DefectDef>
-->
	</DefectDefGroup>
	<DefectDefGroup guid="b86a5928-990f-4bf1-a584-2fd05a03aa02" id="231" name="Precedence" symbol="DEFECT_DESCRIPTION__">
		<doc>
			<p>
                PRE<i>f</i>ast detects a variety of errors in precedence.
                The following errors are reported in this category.
            </p>
		</doc>
		<ownerURL>http://anyURL</ownerURL>
		<ownerContact>anyAlias</ownerContact>
		<!--  -->
		<DefectDef guid="873b0dce-22ed-4ab8-9ad2-1bfe58e09d00" id="99101" name="InternalError">
			<description>
				<format>
                    Internal Error
                </format>
			</description>
			<additionalInfo>
				<format>
                    Precedence: %description% %code%
                </format>
				<param name="description" format="'%ls'" display=""/>
				<param name="code" format="%d" display=""/>
			</additionalInfo>
			<doc type="html">
				<p>
                    This warning indicates that PRE<i>f</i>ast has
                    encountered unexpected behavior in the precedence module.
                </p>
				<p>
                    Please report any occurrences of this warning to the <a href="mailto:pftbug">PRE<i>f</i>ast Bug Reports and Suggestions
                    alias</a>.  Please include the entire warning message in
                    your mail.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%">
				<!-- BUGBUG:  Any way to generate this now ? -->
				<defectiveSrc/>
			</example>
			<!-- BUGBUG:  We don't live in 8.3 land anymore why is this just ".htm" ? -->
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="88451afe-3d92-4131-a612-b6f755f46c10" id="99102" name="InternalException">
			<description>
				<format>
                    Internal Exception
                </format>
			</description>
			<doc type="html">
				<p>
                    This warning indicates that PRE<i>f</i>ast has
                    encountered unexpected behavior in a plugin.
                </p>
				<p>                    
                    Please report any occurrences of this warning to the <a href="mailto:pftbug">PRE<i>f</i>ast Bug Reports and Suggestions
                    alias</a>.  Please include the entire warning message in
                    your mail.
                </p>
			</doc>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="8b86c916-1829-45f7-8e19-8e3b3c719f35" id="99103" name="InternalCOMException">
			<description>
				<format>
                    Internal COM Exception
                </format>
			</description>
			<doc type="html">
				<p>
                    This warning indicates that PRE<i>f</i>ast has
                    encountered unexpected behavior in a plugin.
                </p>
				<p>                    
                    Please report any occurrences of this warning to the <a href="mailto:pftbug">PRE<i>f</i>ast Bug Reports and Suggestions
                    alias</a>.  Please include the entire warning message in
                    your mail.
                </p>
			</doc>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<DefectDef guid="d2599e9d-f4b7-4d1f-94f9-8d8297f0226d" id="99104" name="PluginVersionMismatch">
			<description>
				<format>
                    Plugin version mismatch : %module% version %num1% doesn't match the version %num2%
					of the PREfast driver
                </format>
				<param name="module" format="'%ls'"/>
				<param name="num1" format="'%d'"/>
				<param name="num2" format="'%d'"/>
			</description>
			<doc type="html">
				<p>
                    This warning indicates that the reported plugin is incompatible with 
					the rest of the PRE<i>f</i>ast installation. This plugin will not
					used in the PRE<i>f</i>ast analysis.
                </p>
				<p>                    
                    Please report any occurrences of this warning to the <a href="mailto:pftbug">PRE<i>f</i>ast Bug Reports and Suggestions
                    alias</a>.  Please include the entire warning message in
                    your mail.
                </p>
			</doc>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleConstLogicalOp -->
		<DefectDef guid="80a29b3b-4c41-4a8b-97b6-723734a81c15" id="235" name="NonZeroLogicalOr">
			<description>
				<format>    
                    (%nzc% || %expr%) is always TRUE
                </format>
				<param name="nzc" format="&lt;non-zero constant&gt;" display="&lt;non-zero constant&gt;"/>
				<param name="expr" format="&lt;expression&gt;" display="&lt;expression&gt;"/>
			</description>
			<question>
				<format>
                    Was the bitwise-or operator intended
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that a constant value greater than
                    one was detected on the left side of a logical-or
                    operation that occurs in a test context.  The resulting
                    expression always evaluates to <code>TRUE</code>.  Any
                    side effect occurring on the right side of the
                    expression is lost.
                </p>
				<p>
                    A constant value greater than one suggests that
                    <code>|</code> or <code>&amp;</code> might have been
                    intended.  Otherwise consider using a constant that
                    evaluates to 1. 
                </p>
			</doc>
			<example funcBody="void Precedence_%id%">
				<defectiveSrc><![CDATA[
                    int n = 15;

                    if (2 || n) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    int n = 15;

                    /* Explicitly show that side-effects of n are unimportant */

                    if (2 /* || n */) {;}


                    /* Change the constant to 1. */

                    if (1 || n) {;}


                    /* Change the operator to |. */

                    if (2 | n) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleConstLogicalOp -->
		<DefectDef guid="60059332-0c26-485e-bd86-dc1d78a731a5" id="236" name="LogicalOrNonZero">
			<description>
				<format>
                    (%expr% || %nzc%) is always TRUE
                </format>
				<param name="expr" format="&lt;expression&gt;" display="&lt;expression&gt;"/>
				<param name="nzc" format="&lt;non-zero constant&gt;" display="&lt;non-zero constant&gt;"/>
			</description>
			<question>
				<format>
                    Was the bitwise-and operator intended
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that a constant value greater than
                    one detected on the right side of a logical-or operation
                    that occurs in a test context.  The resulting expression
                    always evaluates to <code>TRUE</code>.
                </p>
				<p>
                    A constant value greater than one suggests that
                    <code>|</code> or <code>&amp;</code> might have been
                    intended.  If not, consider using a constant that
                    evaluates to 1.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int x)">
				<defectiveSrc><![CDATA[
                    if (x || 3) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (x & 3) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleConstLogicalOp -->
		<DefectDef guid="79f30e2b-59ac-4ca7-80b2-5d8e59f95d85" id="237" name="ZeroLogicalAndLosingSideEffects">
			<description>
				<format>
                    (%zero% &amp;&amp; %expr%) is always FALSE
                </format>
				<param name="zero" format="&lt;zero&gt;" display="&lt;zero&gt;"/>
				<param name="expr" format="&lt;expression&gt;" display="&lt;expression&gt;"/>
			</description>
			<consequence>
				<format>
                    &lt;<i>expression</i>&gt; is never evaluated and may
                    have side effects
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that a constant value of zero was
                    detected on the left side of a logical-and operation
                    that occurs in a test context.  The resulting expression
                    always evaluates to <code>FALSE</code> and any side
                    effect occurring on the right side of the expression is
                    lost.
                </p>
				<p>
                    You may wish to examine the right side of the expression
                    carefully to ensure that any side effects needed for
                    proper functionality are not lost.
                </p>
				<p>
                    The <code>(0 &amp;&amp; n)</code> construction is
                    commonly used to disable the result of a test.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int x)">
				<defectiveSrc><![CDATA[
                    if (0 && x++) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (0) {
                        if (x++) {;}
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleConstLogicalOp -->
		<DefectDef guid="430f28c0-2a69-4406-a530-6d653390e4be" id="239" name="NonZeroLogicalAnd">
			<description>
				<format>
                    (%nzc% &amp;&amp; %expr%) always evaluates to the
                    Boolean result of %expr%
                </format>
				<param name="nzc" format="&lt;non-zero constant&gt;" display="&lt;non-zero constant&gt;"/>
				<param name="expr" format="&lt;expression&gt;" display="&lt;expression&gt;"/>
			</description>
			<question>
				<format>
                    Was the bitwise-and operator intended
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that a constant value greater
                    than one was detected on the left side of a logical-and
                    operation that occurs in a test context.  This
                    expression reduces to a constant value of
                    <code>!!n</code>, which is either 0 or 1.
                </p>
				<p>
                    This warning is typically caused by an attempt to mask
                    bits in which the operator should be <code>&amp;</code>.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int x)">
				<defectiveSrc><![CDATA[
                    if (3 && x) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (3 & x) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleConstLogicalOp -->
		<DefectDef guid="e7de9622-2b27-43bb-90ec-5b36be8f94da" id="240" name="LogicalAndNonZero">
			<description>
				<format>
                    (%expr% &amp;&amp; %nzc%) always evaluates to the
                    Boolean result of %expr%
                </format>
				<param name="expr" format="&lt;expression&gt;" display="&lt;expression&gt;"/>
				<param name="nzc" format="&lt;non-zero constant&gt;" display="&lt;non-zero constant&gt;"/>
			</description>
			<question>
				<format>
                    Was the bitwise-and operator intended
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that a constant value greater
                    than one was detected on the right side of a logical-and
                    operation that occurs in a test context.  This
                    expression reduces to a constant value of
                    <code>!!n</code>, which is 0 or 1.
                </p>
				<p>
                    This warning is typically caused by an attempt to mask
                    bits in which case the operator should be
                    <code>&amp;</code>.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int x)">
				<defectiveSrc><![CDATA[
                    if (x && 3) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (x & 3) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkTRYFINALLY -->
		<DefectDef guid="24f3d820-be92-4521-bd13-17108b39a0c6" id="241" name="CollidedReturnFromTryFinally">
			<description>
				<format>
                    Value returned from this finally-block overrides the
                    value returned from its corresponding try-block
                </format>
			</description>
			<additionalInfo>
				<format>
                    see previous return at %location%
                </format>
				<param name="location" format="line %d of %hs"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that a return statement occurs in
                    both the protected and handler blocks of a try-finally.
                </p>
				<p>
                    When a value is returned from not the protected and
                    handler blocks of a try-finally, the last value
                    returned, the one from the finally block, wins.
                </p>
			</doc>
			<example funcBody="int Precedence_%id%" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    __try {
                        if (rand()) {
                            return 1;
                        }
                    } __finally {
                        if (rand()) {
                            return 2;
                        }
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    int RetVal;

                    __try {
                        if (rand()) {
                            RetVal = 1;
                            __leave;
                        }
                    } __finally {
                        if (rand()) {
                            RetVal = 2;
                        }
                    }

                    return RetVal;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- Walk(BREAK,CONTINUE,RETURN) -->
		<DefectDef guid="91ef53c4-b656-423e-ac9d-c95f88b595d8" id="242" name="LocalUnwindForced">
			<description>
				<format>
                    A jump out of this try block forces local unwind
                </format>
			</description>
			<consequence>
				<format>
                    Incurs severe performance penalty
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that a jump statement causes
                    control-flow to leave the protected block of a
                    try-finally other than by 'fall-through'.
                </p>
				<p>
                    Leaving the protected block of a try-finally other than
                    by falling through from the last statement requires
                    local unwind to occur.  Local unwind typically (on mips,
                    ppc, alpha, and IA64) requires on the order of 1000
                    machine instructions so is detrimental to performance.
                </p>
				<p>
                    Use <code>_leave</code> to exit the protected block of a
                    try-finally.
                </p>
			</doc>
			<example funcBody="int Precedence_%id%" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    __try {
                        if (rand()) {
                            return 1;
                        }
                    } __finally {
                        ;
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    int RetVal;

                    __try {
                        if (rand()) {
                            RetVal = 1;
                            __leave;
                        }
                    } __finally {
                        ;
                    }

                    return RetVal;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkRETURN -->
		<DefectDef guid="71654e93-0395-47cd-8d36-f05ae534ec4e" id="243" name="GlobalUnwindHalted">
			<description>
				<format>
                    Return from a finally-block halts global unwind
                </format>
			</description>
			<consequence>
				<format>
                    The exception will not be propagated
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that a return statement occurs in
                    the handler of a try-finally statement.
                </p>
				<p>
                    A try-finally is intended to allow guaranteed cleanup,
                    not exception handling.  Returning from the finally
                    block will handle the exception if one occurred in the
                    protected block; the exception will not be propagated
                    upwards.
                </p>
			</doc>
			<example funcBody="int Precedence_%id%" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    __try {
                        ;
                    } __finally {
                        if (rand()) {
                            return 2;
                        }
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    int RetVal;

                    __try {
                        ;
                    } __finally {
                        if (rand()) {
                            RetVal = 2;
                        }
                    }

                    return RetVal;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- WalkDECLARATION -->
		<DefectDefGroup guid="53875b46-b1ab-47c1-a4e5-aa84773937b9" id="244" name="DeclHidingBase">
			<DefectDef guid="1f472570-944e-45fa-b35f-3825ef5aaabf" id="244" name="LocalDeclHidesGlobal">
				<description>
					<format>
                        Local declaration of %variable% hides global
                        declaration
                    </format>
					<param name="variable" format="'%ls'"/>
				</description>
				<additionalInfo>
					<format>
                        see previous declaration at %location%
                    </format>
					<param name="location" format="line %d of %hs"/>
				</additionalInfo>
				<doc>
					<p>
                        The warning indicates that a local declaration has
                        the same name as a declaration at global scope and
                        hides the global declaration.
                    </p>
					<p>
                        It is necessary to understand how the actual
                        lifetimes of these two definitions overlap in order
                        to determine whether there is a problem with this
                        code; PRE<i>f</i>ast only identifies a scope
                        overlap.  If the actual lifetimes of the variables
                        overlap there could be a problem. Things to look for
                        when investigating this warning are:
                        <ul>
							<li>
                                Is the intent a single variable or multiple
                                variables ?
                            </li>
							<li>
                                Is an allocation saved in one variable and
                                freed by the other ?
                            </li>
							<li>
                                Is the correct result being returned ?
                            </li>
						</ul>
					</p>
				</doc>
				<example funcBody="void Precedence_%id%">
					<!-- BUGBUG:  Can't create an example for this one unless we can get a decl
              at global scope.-->
					<defectiveSrc><![CDATA[
                    ]]></defectiveSrc>
					<correctedSrc><![CDATA[
                    ]]></correctedSrc>
				</example>
				<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
			</DefectDef>
			<!--  -->
			<DefectDef guid="b0f0c480-3d5d-4268-b82a-b8ec56938159" id="245" name="ForInitDeclHidesGlobal">
				<description>
					<format>
                        For-init declaration of %variable% hides global
                        declaration
                    </format>
					<param name="variable" format="'%ls'"/>
				</description>
				<additionalInfo>
					<format>
                        see previous declaration at %location%
                    </format>
					<param name="location" format="line %d of %hs"/>
				</additionalInfo>
				<doc>
					<p>
                        This warning indicates that a declaration in a
                        for-initializer has the same name as a declaration
                        at global scope and hides the global declaration.
                    </p>
					<p>
                        It is necessary to understand how the actual
                        lifetimes of these two definitions overlap in order
                        to determine whether there is a problem with this
                        code; PRE<i>f</i>ast only identifies a scope
                        overlap.  If the actual lifetimes of the variables
                        overlap there could be a problem. Things to look for
                        when investigating this warning are:
                        <ul>
							<li>
                                Is the intent a single variable or multiple
                                variables ?
                            </li>
							<li>
                                Is an allocation saved in one variable and
                                freed by the other ?
                            </li>
							<li>
                                Is the correct result being returned ?
                            </li>
						</ul>
					</p>
				</doc>
				<example funcBody="void Precedence_%id%">
					<!-- BUGBUG:  Can't create an example for this one unless we can get a decl
              at global scope.-->
					<defectiveSrc><![CDATA[
                    ]]></defectiveSrc>
					<correctedSrc><![CDATA[
                    ]]></correctedSrc>
				</example>
				<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
			</DefectDef>
			<!--  -->
			<DefectDef guid="f95f5cda-7e92-47cc-982f-df1a458e0bc4" id="246" name="LocalDeclHidesLocal">
				<description>
					<format>
                        Local declaration of %variable% hides declaration of
                        the same name in an outer scope
                    </format>
					<param name="variable" format="'%ls'"/>
				</description>
				<additionalInfo>
					<format>
                        see previous declaration at %location%
                    </format>
					<param name="location" format="line %d of %hs"/>
				</additionalInfo>
				<doc>
					<p>
                        This warning indicates that a local declaration
                        has the same name as a declaration at global scope.
                        The name at global scope is hidden by the
                        declaration at scope.
                    </p>
					<p>
                        It is necessary to understand how the actual
                        lifetimes of these two definitions overlap in order
                        to determine whether there is a problem with this
                        code; PRE<i>f</i>ast only identifies a scope
                        overlap.  If the actual lifetimes of the variables
                        overlap there could be a problem. Things to look for
                        when investigating this warning are:
                        <ul>
							<li>
                                Is the intent a single variable or multiple
                                variables ?
                            </li>
							<li>
                                Is an allocation saved in one variable and
                                freed by the other ?
                            </li>
							<li>
                                Is the correct result being returned ?
                            </li>
						</ul>
					</p>
				</doc>
				<example funcBody="int Precedence_%id%" sysIncludes="stdlib.h">
					<defectiveSrc><![CDATA[
                        int Decl1 = 42;

                        {
                            int Decl1;

                            Decl1 = rand();
                        }

                        return Decl1;
                    ]]></defectiveSrc>
					<correctedSrc><![CDATA[
                        int Decl1 = 42;

                        {
                            int Decl2;

                            Decl2 = rand();
                        }

                        return Decl1;
                    ]]></correctedSrc>
				</example>
				<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
			</DefectDef>
			<!--  -->
			<DefectDef guid="a1e5903f-cb0e-43c5-b32e-fcd533bf53d1" id="247" name="ForInitDeclHidesLocal">
				<description>
					<format>
                        For-init declaration of %variable% hides a
                        declaration of the same name in an outer scope
                    </format>
					<param name="variable" format="'%ls'"/>
				</description>
				<additionalInfo>
					<format>
                        See previous declaration at %location%
                    </format>
					<param name="location" format="line %d of %hs"/>
				</additionalInfo>
				<doc>
					<p>
                        This warning indicates that a local declaration has
                        the same name as a declaration in an outer scope.
                        The name in the outer scope is hidden.
                    </p>
					<p>
                        It is necessary to understand how the actual
                        lifetimes of these two definitions overlap in order
                        to determine whether there is a problem with this
                        code; PRE<i>f</i>ast only identifies a scope
                        overlap.  If the actual lifetimes of the variables
                        overlap there could be a problem. Things to look for
                        when investigating this warning are:
                        <ul>
							<li>
                                Is the intent a single variable or multiple
                                variables ?
                            </li>
							<li>
                                Is an allocation saved in one variable and
                                freed by the other ?
                            </li>
							<li>
                                Is the correct result being returned ?
                            </li>
						</ul>
					</p>
				</doc>
				<example funcBody="void Precedence_%id%">
					<defectiveSrc><![CDATA[
                        int Decl1;

                        {
                            for (int Decl1 = 0;;) {
                                ;
                            }
                        }
                    ]]></defectiveSrc>
					<correctedSrc><![CDATA[
                        int Decl1;

                        {
                            for (int Decl2 = 0;;) {
                                ;
                            }
                        }
                    ]]></correctedSrc>
				</example>
				<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
			</DefectDef>
		</DefectDefGroup>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="4a2e7582-7b15-4e42-a450-4885b485e388" id="248" name="CreatingNULLDACL">
			<description>
				<format>
                    Setting a SECURITY_DESCRIPTOR's DACL to NULL will result
                    in an unprotected object
                </format>
			</description>
			<additionalInfo>
				<format>
                    violates CC/C2 security requirements
                </format>
			</additionalInfo>
			<doc>
				<p>
                    This warning identifies a call which sets a
                    <code>SECURITY_DESCRIPTOR</code>'s <code>DACL</code>
                    field to <code>NULL</code>.  Objects with
                    <code>NULL DACL</code>s can have their security
                    descriptors altered by malicious users so that no one
                    has access to the object.
                </p>
				<p>
                    If everyone needs access to an object, the object
                    should be secured so that only administrators can alter
                    its security.
                </p>
				<p>
                    If only the creator needs access to an object, a
                    <code>DACL</code> should not be set on the object; the
                    system will choose an appropriate default.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="nt.h;ntrtl.h;nturtl.h">
				<defectiveSrc><![CDATA[
                    RtlSetDaclSecurityDescriptor(NULL,
                                                 TRUE,
                                                 NULL,
                                                 FALSE);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    ;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="ea935d9b-c59d-47e6-aae2-b0ae6c0198cc" id="249" name="KernelUnreleasedVADs">
			<description>
				<format>
                    Calling %function% without the MEM_RELEASE flag frees
                    memory but not the address descriptors (VADs)
                </format>
				<param name="function" format="'%ls'" display="&lt;kernel function&gt;"/>
			</description>
			<consequence>
				<format>
                    Results in address space leaks
                </format>
			</consequence>
			<doc>
				<p>
                    This warning is specific to Windows NT kernel-mode code.
                </p>
				<p>
                    This message warns you that you must use
                    <code>MEM_RELEASE</code>
                    with <code>NtFreeVirtualMemory</code> to unreserve
                    memory that was reserved or committed using
                    <code>NtAllocateVirtualMemory</code>.
                </p>
				<p>
					<code>NtAllocateVirtualMemory</code> can reserve or
                    commit memory.  A commit of memory also reserves it.
                    <code>MEM_DECOMMIT</code> undoes the commit, but not the
                    reserve.  <code>MEM_RELEASE</code> undoes the reserve.
                </p>
				<p>
					<code>NtFreeVirtualMemory</code> behaves similarly to
                    the Win32 function <code>VirtualFree</code>.  MSDN
                    documentation for <code>VirtualFree</code> states the
                    following:

                    <ul>
						<i>"If a page is decommitted but not released, its
                        state changes to reserved..."</i>
					</ul>

                    Thus, to completely release committed memory, it must be
                    decommitted and released.
                </p>
				<p>
                    It is not necessary for the decommit and release to
                    happen as independent steps.  Releasing committed memory
                    will decommit the pages as well.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="nt.h;ntos.h">
				<defectiveSrc><![CDATA[
                ZwFreeVirtualMemory(0,
                                    NULL,
                                    0,
                                    MEM_DECOMMIT);

                ZwFreeVirtualMemory(0,
                                    NULL,
                                    0,
                                    MEM_RELEASE);
            ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                ZwFreeVirtualMemory(0,
                                    NULL,
                                    0,
                                    MEM_RELEASE);
            ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="81f02611-1b60-4894-a740-b703732d7879" id="250" name="Win32UnreleasedVADs">
			<description>
				<format>
                    Calling %function% without the MEM_RELEASE flag frees
                    memory but not address descriptors (VADs)
                </format>
				<param name="function" format="%ls"/>
			</description>
			<consequence>
				<format>
                    Results in address space leaks
                </format>
			</consequence>
			<doc>
				<p>
                    This message warns you that you must use
                    <code>MEM_RELEASE</code>
                    with <code>VirtualFree</code> to unreserve memory that
                    was reserved or committed using
                    <code>VirtualAllocate</code>.
                </p>
				<p>
					<code>VirtualAlloc</code> can reserve or commit memory.
                    A commit of memory also reserves it.
                    <code>MEM_DECOMMIT</code> undoes the commit, but not the
                    reserve.  <code>MEM_RELEASE</code> undoes the reserve.
                </p>
				<p>
                    MSDN documentation for <code>VirtualFree</code> states
                    the following:

                    <ul>
						<i>"If a page is decommitted but not released, its
                        state changes to reserved..."</i>
					</ul>

                    Thus, to completely release committed memory, it must be
                    released.
                </p>
				<p>
                    It is not necessary for the decommit and release to
                    happen as independent steps.  Releasing committed memory
                    will decommit the pages as well.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    VirtualFree(NULL,
                                0,
                                MEM_DECOMMIT);

                    VirtualFree(NULL,
                                0,
                                MEM_RELEASE);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    VirtualFree(NULL,
                                0,
                                MEM_RELEASE);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="b77a14e3-6a2d-4a75-a23e-198c0e85f36a" id="251" name="InitCritSRaisesOnFailure">
			<description>
				<format>
                    InitializeCriticalSection indicates failure by raising
                    an asynchronous exception
                </format>
			</description>
			<additionalInfo>
				<format>
                    not protected by local exception handling
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Consider using an exception handler
                </format>
			</recommendedFix>
			<doc>
				<p>
                    This warning indicates that a call to
                    <code>InitializeCriticalSection</code> was detected
                    outside of local exception handling.
                </p>
				<p>
                    MSDN documentation of
                    <code>InitializeCriticalSection</code> states the
                    following: 

                    <ul>
						<i>In low memory situations,
                        InitializeCriticalSection can raise a
                        STATUS_NO_MEMORY exception...</i>
					</ul>

                    Most code does not protect against this properly.
                </p>
				<p>
                    This warning is disabled by default, but can be enabled
                    by using the <b>/EnableCritsWarning</b> command-line
                    switch when invoking PRE<i>f</i>ast.
                </p>
				<p>
                    For example, the following command-line will enable
                    this warning:

                    <ul><code>
                        prefast /EnableCritsWarning=1 cl /Zs test.c
                    </code></ul>
				</p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="windows.h" globalDecls="CRITICAL_SECTION Cs">
				<defectiveSrc><![CDATA[
                    InitializeCriticalSection(&Cs);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    __try {
                        InitializeCriticalSection(&Cs);
                    } __except(1) {
                        return;     // initialization failed
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="ad2a648d-ca33-4fda-9673-48d98ced4ded" id="252" name="UntaggedAllocation">
			<description>
				<format>
                    Untagged pool allocation
                </format>
			</description>
			<consequence>
				<format>
                    Interferes with debugging
                </format>
			</consequence>
			<doc>
				<p>
                    This warning is specific to Windows NT kernel-mode code.
                </p>
				<p>
                    This warning indicates that all pool allocations should
                    use tags to assist debugging memory leaks and pool
                    corrupting events.
                </p>
				<p>
                    For example, a call to <code>ExAllocatePool</code>
                    should be changes to a call to
                    <code>ExAllocatePoolWithTag</code>.  Similarly, a call
                    to <code>ExAllocatePoolWithQuota</code> should be
                    changed to a call to
                    <code>ExAllocatePoolWithQuotaTag</code>.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="nt.h;ntos.h">
				<defectiveSrc><![CDATA[
                    ExAllocatePool(0,
                                   512);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    ExAllocatePoolWithTag(0,
                                          512,
                                          'kael');
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="e3d63412-77e6-47b9-a4d2-2ca99d72b2fa" id="253" name="MMSecureVMNearlyUseless">
			<description>
				<format>
                    MmSecureVirtualMemory locks VADs not pages
                </format>
			</description>
			<additionalInfo>
				<format>
                    dereferences must still be protected by try-except
                </format>
			</additionalInfo>
			<doc>
				<p>
                    This warning is specific to Windows NT kernel-mode code.
                </p>
				<p>
                    This warning reminds us that
                    <code>MmSecureVirtualMemory</code> only locks the VADs
                    in a process' address space, but not the underlying
                    data.  This function is typically used to secure VADs of
                    a user process' memory space.  The data can still be
                    paged out.  If a failure to page in user-mode data
                    occurs, a page fault will be raised; if this page fault
                    is not handled the system will crash.
                </p>
				<p>
					<i>This warning is of limited value as there is no way
                    to 'fix' it.</i>
				</p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="nt.h;ntos.h">
				<defectiveSrc><![CDATA[
                    MmSecureVirtualMemory(NULL,
                                          0,
                                          0);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    ; // use something else
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- HandleAlloca -->
		<DefectDef guid="23cc5233-3b5a-4455-a09c-269437fd380e" id="255" name="UnprotectedUseOfAlloca">
			<description>
				<format>
					<code>_alloca</code> indicates failure by raising a
                    stack overflow exception
                </format>
			</description>
			<recommendedFix>
				<format>
                    Consider using an exception handler
                </format>
			</recommendedFix>
			<doc>
				<p>
                    This warning indicates that a call to
                    <code>_alloca</code> has been detected outside of local
                    exception handling.  <code>_alloca</code> should always
                    be called from within the protected range of an
                    exception handler because it can raise a stack overflow
                    exception on failure.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="malloc.h;windows.h">
				<defectiveSrc><![CDATA[
                    _alloca(10);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    __try {
                        _alloca(10);
                    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
                        _resetstkoflw();
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- HandleAlloca -->
		<!-- Warning 256 is not currently reported
        <DefectDef guid="6475464c-b568-4d23-8a2e-22c0aada7a49"
            id="256"
            name="SEHProtectedUseOfAlloca">

            <description>
                <format>
                    Stack not repaired after handled exception from
                    <code>_alloca</code>
                </format>
            </description>

            <recommendedFix>
                <format>
                    Consider calling _resetstkoflw
                </format>
            </recommendedFix>

            <doc>
                <p>
                    This warning is currently disabled because it's not
                    clear how to fix.
                </p>
            </doc>

            <example funcBody="void Precedence_%id%" sysIncludes="stdlib.h">
                <defectiveSrc><![CDATA[
                    __try {
                        _alloca(10);
                    } __except(EXCEPTION_EXECUTE_HANDLER) {
                            ;
                    }
                ]]></defectiveSrc>
                <correctedSrc><![CDATA[
                    __try {
                        _alloca(10);
                    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
                        _resetstkoflw();
                    }
                ]]></correctedSrc>
            </example>

            <helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
        </DefectDef>
-->
		<!--  -->
		<!-- HandleAlloca -->
		<DefectDef guid="ba2a20bc-d4a2-439c-acbb-e24507da2ceb" id="257" name="ProhibitedUseOfAlloca">
			<description>
				<format>
					<code>_alloca</code> used in prohibited location
                </format>
			</description>
			<additionalInfo>
				<format>
                    consult MSDN for restrictions on using
                    <code>_alloca</code> in an exception handler
                </format>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that <code>_alloca</code> is
                    called from a location that does not allow this.
                </p>
				<p>
                    The MSDN documentation for <code>_alloca</code>
                    identifies some locations from which it cannot be called:

                    <ul><i>
                        "There are restrictions to explicitly calling
                        _alloca in a exception handler (EH).  EH routines
                        that run on x86-class processors operate in their
                        own memory "frame":  They perform their tasks in
                        memory space that is not based on the current
                        location of the stack pointer of the enclosing
                        function.  The most common implementations include
                        Windows NT structured exception handling (SEH) and
                        the C++ catch clause expressions.  Therefore,
                        explicitly calling _alloca in any of the following
                        scenarios results in program failure during the
                        return to the calling EH routine:

                        <ul>
								<li>
                                Windows NT SEH exception filter expression:
                                __except ( _alloca() )
                            </li>
								<li>
                                Windows NT SEH final exception handler:
                                __finally { _alloca() }
                            </li>
								<li>
                                C++ EH catch clause expression"
                            </li>
							</ul>
						</i></ul>

                    VC 7 apparently catches the last case as <code>C3204,
                    "you cannot call _alloca from within a catch block".</code>
				</p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="stdlib.h;malloc.h">
				<defectiveSrc><![CDATA[
                    char *a;

                    __try {
                        ;
                    } __except (a = (char *)_alloca(10)) {
                        ;
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char *a;

                    a = (char *)malloc(10);

                    if (a == NULL) {
                        return;
                    }

                    __try {
                        ;
                    } __except (a) {
                        ;
                    }

                    free(a);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="dab47611-f73b-4201-b3d7-14d5aeaa264e" id="258" name="UsingTerminateThread">
			<description>
				<format>
                    Using TerminateThread does not allow proper thread clean
                    up
                </format>
			</description>
			<additionalInfo>
				<format>
                    consult MSDN for more information
                </format>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that a call to
                    <code>TerminateThread</code> has been detected.
                </p>
				<p>
                    MSDN cautions us against the use of
                    <code>TerminateThread</code>:

                    <ul><i>
                        TerminateThread is a dangerous function that should
                        only be used in the most extreme cases.  You should
                        call TerminateThread only if you know exactly what
                        the target thread is doing, and you control all of
                        the code that the target thread could possibly be
                        running at the time of termination.  For example,
                        TerminateThread can result in the following problems:

                        <ul>
								<li>
                                If the target thread owns a critical
                                section, the critical section will not be
                                released.
                            </li>
								<li>
                                If the target thread is executing certain
                                kernel32 calls when it is terminated, the
                                kernel32 state for the thread's process
                                could be inconsistent.
                            </li>
								<li>
                                If the target thread is manipulating the
                                global state of a shared DLL, the state of
                                the shared DLL could be destroyed, affecting
                                other users of the DLL.
                            </li>
							</ul>

                        A thread cannot protect itself against
                        TerminateThread, other than by controlling access to
                        its handles.  The thread handle returned by
                        CreateThread and CreateProcess functions has
                        THREAD_TERMINATE access, so any caller holding one
                        of these handles can terminate your thread.
                    </i></ul>

                    Note that <code>SuspendThread</code> has similar
                    problems, but that PRE<i>f</i>ast does not currently
                    detect use of this API.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(HANDLE Thread)" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    TerminateThread(Thread,
                                    0);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    extern HANDLE ThreadTerminationEvent[];

                    SetEvent(ThreadTerminationEvent[(ULONG)Thread]);

                    /*
                     * Target thread waits on/polls the termination event
                     * and gracefully releases locks and resources before
                     * calling ExitThread().
                     */
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkCASE -->
		<DefectDef guid="aa8792f1-2937-4e3c-9735-c7685b0d8d00" id="259" name="DeadCodeInBitOrLimitedSwitch">
			<description>
				<format>
                    Labeled code is unreachable
                </format>
			</description>
			<additionalInfo>
				<format>
                    (%expr% &amp; %c1%) in a switch-expr limits
                    case values to a maximum of %c2%
                </format>
				<param name="expr" format="&lt;expression&gt;" display="&lt;expression&gt;"/>
				<param name="c1" format="0x%lx" display="&lt;constant&gt;"/>
				<param name="c2" format="0x%lx" display="&lt;constant&gt;"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates dead code caused by a mask
                    operation in a switch-expr.  The related case statements
                    which exceed the constant are not reachable.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    switch (rand () & 3) {
                        case 3:

                            /* Reachable */

                            break;

                        case 4:

                            /* Not reachable */

                            break;

                        default:

                            break;
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    switch (rand () & 3) {
                        case 3:

                            /* Reachable */

                            break;

                        default:

                            break;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkMULT -->
		<DefectDef guid="643aa8f2-f283-4d01-9840-6099769d67a9" id="260" name="UseOfByteArea">
			<description>
				<format>
                    Sizeof * sizeof is almost always wrong
                </format>
			</description>
			<additionalInfo>
				<format>
                    %v1% * %v2%
                </format>
				<param name="v1" format="%d" display="&lt;value&gt;"/>
				<param name="v2" format="%d" display="&lt;value&gt;"/>
			</additionalInfo>
			<question>
				<format>
                    Was a character count or a byte count intended
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that the results of two
                    <code>sizeof</code> operations have been multiplied
                    together.
                </p>
				<p>
                    The C/C++ <code>sizeof</code> operator returns the
                    number of bytes of storage an object uses.  It is
                    typically incorrect to multiply it by the result of
                    another <code>sizeof</code> operation.  Usually one is
                    interested in the number of bytes  in an object or the
                    number of elements in an array (for example the number
                    of wide-characters in an array).
                </p>
				<p>
                    Here's a quirk to be aware of.  In C, the following holds:
                    <ul>
						<code>
                            sizeof ('\0') == 4
                        </code>
					</ul>
                    because the type of a character literal is
                    <code>int</code>.  In C++, the type of a character
                    literal is <code>char</code>, so:
                    <ul>
						<code>
                            sizeof ('\0') == 1.
                        </code>
					</ul>
                    In both C and C++, the following holds:
                    <ul>
						<code>
                            sizeof ("\0") == 2.
                        </code>
					</ul>
				</p>
			</doc>
			<example funcBody="void Precedence_%id%" globalDecls="typedef unsigned short WCHAR;">
				<defectiveSrc><![CDATA[
                    int a;

                    a = sizeof (L"String") * sizeof (WCHAR);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    int a;

                    /* To get characters in string: */

                    a = sizeof (L"String") / sizeof (WCHAR);


                    /* To get bytes string: */

                    a = sizeof (L"String");
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="5EF2B35B-067E-4666-BEAE-FAE6E921B3D7" id="261" name="MustSucceedAllocation">
			<description>
				<format>
                    MustSucceed pool allocations are forbidden
                </format>
			</description>
			<consequence>
				<format>
                    MustSucceed allocation failures cause a system crash
                </format>
			</consequence>
			<doc>
				<p>
                    This warning is specific to Windows NT kernel-mode code.
                </p>
				<p>
                    This warning indicates an attempt to allocate
                    MustSucceed pool.
                </p>
				<p>
                    MustSucceed pool allocations fail by crashing the system
                    so its use in Whistler and beyond has been prohibited.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="nt.h;ntos.h">
				<defectiveSrc><![CDATA[
                    char *b;

                    b = (char *)ExAllocatePoolWithTag(NonPagedPoolMustSucceed,
                                                      100,
                                                      ' gaT');
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char *b;

                    b = (char *)ExAllocatePoolWithTag(NonPagedPool,
                                                      100,
                                                      ' gaT');
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCDECL -->
		<DefectDef guid="5dc70e05-fbea-4726-8f76-2ababa6fd879" id="262" name="ExcessiveStackUsage">
			<description>
				<format>
                    This function uses %constant% bytes of stack
                </format>
				<param name="constant" format="%d"/>
			</description>
			<additionalInfo>
				<format>
                    exceeds /StackHogThreshold=%constant%
                </format>
				<param name="constant" format="%d"/>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Consider moving some data to heap
                </format>
			</recommendedFix>
			<doc>
				<p>
                    This warning indicates that stack usage exceeding a
                    preset threshold has been detected.  The default
                    threshold for this warning is 16k bytes.
                </p>
				<p>
                    Stack, even in user-mode, is limited, and failure to
                    commit a page of stack results in an unhandlable
                    exception.
                </p>
				<p>
                    The detection threshold for this warning is adjustable
                    using the /STACKHOGTHRESHOLD switch when invoking
                    PRE<i>f</i>ast.  For example:

                    <ul><code>
                        prefast /STACKHOGTHRESHOLD=1024 cl /Zs test.c
                    </code></ul>

                    Will cause this warning to be generated when
                    PRE<i>f</i>ast detects functions using more than 1024
                    bytes of stack.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="malloc.h;stdlib.h">
				<defectiveSrc><![CDATA[
                    char Buffer[123456];
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char *Buffer;

                    Buffer = (char *)malloc(123456);
                    if (Buffer == NULL) {
                        return;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- HandleAlloca -->
		<DefectDef guid="023fc5ba-a470-4f43-89eb-3e9a9101e25d" id="263" name="UsingAllocaInLoop">
			<description>
				<format>
                    Using <code>_alloca</code> in a loop
                </format>
			</description>
			<consequence>
				<format>
                    This can quickly overflow stack
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that a call to
                    <code>_alloca</code> was detected in a loop.
                </p>
				<p>
					<code>_alloca</code> allocates from the stack but is
                    only freed when the calling function exits.
                    <code>_alloca</code> should not be used in loops unless
                    the allocation and iteration counts are well understood
                    and small.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="stdlib.h;malloc.h">
				<defectiveSrc><![CDATA[
                    char *b;

                    do {
                        b = (char *)_alloca(9);

                        ;
                        
                    } while (1);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char *b;

                    do {
                        b = (char *)malloc(9);

                        if (b == NULL) {
                            break;
                        }

                        ;

                        free(b);
                    } while (1);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- BitwiseRelationalPrecedenceErrorWorker -->
		<DefectDef guid="f1f45a43-2585-46e6-95f8-b4d73fb21beb" id="281" name="BitwiseRelationPrecedenceError">
			<description>
				<format>
                    Incorrect order of operations
                </format>
			</description>
			<additionalInfo>
				<format>
                    relational operators have higher precedence than bitwise
                    operators
                </format>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates a probable error in operator
                    precedence.
                </p>
				<p>
                    Relational operators ( <code>&lt; &gt; &lt;= &gt;= ==
                    !=</code> ) have higher precedence than bitwise
                    operators (<code> &amp; | ^ </code>).
                </p>
			</doc>
			<example funcBody="void Precedence_%id%">
				<defectiveSrc><![CDATA[
                    int x = 3, y = 7, z = 13;

                    if (x & y != z) { ; }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    int x = 17, y = 23, z = 31;

                    if ((x & y) != z) { ; }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- CheckBooleanContext -->
		<DefectDef guid="fbf235cf-47c3-4293-96cf-0aaae727d6fa" id="282" name="AssignmentReplacesTest">
			<description>
				<format>
                    Incorrect operator
                </format>
			</description>
			<additionalInfo>
				<format>
                    assignment to constant in test context
                </format>
			</additionalInfo>
			<!-- BUGBUG:  I've changed this some to fit the model, I couldn't find a
schema for defectdefs.xml to see how the agreed form would fit.-->
			<question>
				<format>
                    Was <code>==</code> intended
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that an assignment to a constant
                    was detected in a test context.
                </p>
				<p>
                    Assignment to a constant in a test context is almost
                    always incorrect.  Replace the <code>=</code> with
                    <code>==</code>, or remove the assignment from the
                    test context to resolve this warning.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int a)">
				<defectiveSrc><![CDATA[
                    while (a = 5) {
                        ;
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    while (a == 5) {
                        ;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleConstLogicalOp -->
		<DefectDef guid="A1CBEF7E-0590-483d-B796-FF08495B64BF" id="285" name="LogicalOrOfConstants">
			<description>
				<format>
                    (%nzc% || %nzc%) is always TRUE
                </format>
				<param name="nzc" format="&lt;non-zero constant&gt;" display="&lt;non-zero constant&gt;"/>
			</description>
			<question>
				<format>
                    Was the bitwise-and operator intended
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that two constant values, both
                    greater than one, were detected as arguments to a
                    logical-or operation that occurs in a test context.
                    This expression is always <code>TRUE</code>.
                </p>
				<p>
                    Constant values greater than one suggest that the
                    arguments to logical-or could be bit fields.  Consider
                    whether a bitwise operator, <code>&amp;</code> or
                    <code>|</code>, might be a more appropriate operators in
                    this case. 
                </p>
			</doc>
			<example funcBody="void Precedence_%id%">
				<defectiveSrc><![CDATA[
                    #define     TESTED_VALUE    0x37
                    #define     MASK            0xaa

                    if (TESTED_VALUE || MASK) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    #define     TESTED_VALUE    0x37
                    #define     MASK            0xaa

                    if (TESTED_VALUE & MASK) {;}

                    /* or more rarely */

                    if (TESTED_VALUE | MASK) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleConstLogicalOp -->
		<DefectDef guid="A018BEFB-93F2-4aec-B0B2-9248FCB6FC5C" id="286" name="NonZeroLogicalOrLosingSideEffects">
			<description>
				<format>
                    (%nzc% || %expr%) is always TRUE
                </format>
				<param name="nzc" format="&lt;non-zero constant&gt;" display="&lt;non-zero constant&gt;"/>
				<param name="expr" format="&lt;expression&gt;" display="&lt;expression&gt;"/>
			</description>
			<consequence>
				<format>
                    &lt;<i>expression</i>&gt; is never evaluated and may
                    have side effects
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that a non-zero constant was
                    detected on the left side of a logical-or operation that
                    occurs in a test context.  The resulting expression
                    always evaluates to <code>TRUE</code>.  In addition the
                    right side appears to have side effects, and they will
                    be lost. 
                </p>
				<p>
                    This warning indicates that you may wish to examine the
                    right side of the expression carefully to ensure that
                    any side effects needed for proper functionality are not
                    lost.
                </p>
				<p>
					<!-- BUGBUG:  Is this useful ? -->
                    The <code>(!0 || &lt;<i>expression</i>&gt;)</code>
                    construction is commonly used to force execution of a
                    controlled block.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" globalDecls="extern int foo(void)">
				<defectiveSrc><![CDATA[
                    if (1 || foo()) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (1) {
                        foo();

                        ;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleLogicalCollusion -->
		<DefectDef guid="6387dca1-a731-4e85-a6e3-a78570cd50f7" id="287" name="RedundantTest">
			<description>
				<format>
                    Redundant code
                </format>
			</description>
			<additionalInfo>
				<format>
                    the left and right sub-expressions are identical
                </format>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that redundant element was
                    detected in an expression.
                </p>
				<p>
                    Impact: It is difficult to judge the severity of
                    this problem without examining the code in-situ.  A
                    duplicate test on its own is benign, but if a second
                    test was omitted, the consequences can be severe.  The
                    code should be inspected to ensure that a test was not
                    omitted.
                </p>
				<p>
                    Accuracy:  This warning is highly accurate.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int x, int y)">
				<defectiveSrc><![CDATA[
                        if ((x == 1) && (x == 1)) {;}
                        if ((x != 1) || (x != 1)) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                        /* Remove the redundant sub-expression: */

                        if (x == 1) {;}
                        if (x != 1) {;}

                        /* or test the missing variable: */

                        if ((x == 1) && (y == 1)) {;}
                        if ((x != 1) || (y != 1)) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleLogicalCollusion -->
		<DefectDef guid="8a59d37f-8b97-44e0-a329-12ee445fe2f9" id="288" name="MutualInclusionOverAndIsFalse">
			<description>
				<format>
                    Incorrect operator
                </format>
			</description>
			<additionalInfo>
				<format>
                    mutual inclusion over &amp;&amp; is always FALSE
                </format>
			</additionalInfo>
			<question>
				<format>
                    Was || intended
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that an expression was detected
                    where a variable is being tested against two different
                    constants with the result depending on both conditions
                    being <code>true</code>.  This cannot happen.
                </p>
				<p>
                    This problem is commonly caused by using
                    <code>&amp;&amp;</code>; in place of <code>||</code>, but
                    can also be caused by using <code>==</code> where
                    <code>!=</code> was intended.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int x)">
				<defectiveSrc><![CDATA[
                    if ((x == 1) && (x == 2)) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if ((x == 1) || (x == 2)) {;}

                    /* or */

                    if ((x != 1) && (x != 2)) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleLogicalCollusion -->
		<DefectDef guid="eba62996-c840-4464-ab46-3c52c65f2a51" id="289" name="MutualExclusionOverOrIsTrue">
			<description>
				<format>
                    Incorrect operator
                </format>
			</description>
			<additionalInfo>
				<format>
                    mutual exclusion over || is always TRUE
                </format>
			</additionalInfo>
			<question>
				<format>
                    Was &amp;&amp; intended
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates that an expression was detected
                    where a variable is being tested against two different
                    constants with the result depending on either
                    conditions being <code>true</code>.  This is always the
                    case.
                </p>
				<p>
                    This problem is commonly caused by using <code>||</code>
                    in place of <code>&amp;&amp;</code>, but can also be
                    caused by using <code>!=</code> where <code>==</code>
                    was intended.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int x)">
				<defectiveSrc><![CDATA[
                    if ((x != 1) || (x != 2)) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if ((x != 1) && (x != 2)) {;}

                    /* or */

                    if ((x == 1) || (x == 2)) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleArithmeticBoolConflict -->
		<DefectDef guid="b49c02ac-f8bc-45ad-b9a7-c1cf5e287bdd" id="290" name="LogicalNotBitwiseAnd">
			<description>
				<format>
                    Bitwise operation on logical result
                </format>
			</description>
			<additionalInfo>
				<format>
                    ! has higher precedence than &amp;
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Use &amp;&amp; or (!(x &amp; y)) instead
                </format>
			</recommendedFix>
			<doc>
				<p>
                    The <code>!</code> operator yields a Boolean result, and
                    the <code>&amp;</code> (bitwise-and) operator takes two
                    arithmetic arguments.  The <code>!</code> operator also
                    has higher precedence than <code>&amp;</code>.
                </p>
				<p>
                    Therefore one of the following errors has been detected:
                    <ul>
						<li>
                            The expression is mis-parenthesised:
                            <ul>
                                Since the result of <code>!</code> is
                                Boolean (zero or one), an attempt to test
                                that two variables have bits in common will
                                only end up testing that the lowest bit is
                                present in the right-hand-side:  <code>((!8)
                                &amp; 1) == true</code>.
                            </ul>
						</li>
						<li>
                            The <code>!</code> operator is incorrect, and
                            should be a <code>~</code> instead:
                            <ul>
                                The <code>!</code> operator has a Boolean
                                result, while the <code>~</code> operator
                                has an arithmetic result.  These operators
                                are only interchangeable when operating on a
                                Boolean value (zero or one):  <code>((!0x01)
                                &amp; 0x10) == 0x0</code>, while
                                <code>((~0x01) &amp; 0x10) == 0x10</code>.
                            </ul>
						</li>
						<li>
                            The binary operator <code>&amp;</code> is
                            incorrect, and should instead be
                            <code>&amp;&amp;</code>:
                            <ul>
                                While <code>&amp;</code> can sometimes be
                                interchanged with <code>&amp;&amp;</code>,
                                it is neither equivalent nor efficient as it
                                forces evaluation of the right-hand-side of
                                the expression.  Certain side-effects in
                                this sort of expression can be terminal.
                            </ul>
						</li>
					</ul>
				</p>
				<p>
                    This warning is not reported if the <code>!</code>
                    operator is on the left-hand-side of the <code>&amp;</code>
                    operator as this case is typically the relatively benign
                    case of an incorrect operator.
                </p>
				<p>
                    Impact: It is difficult to judge the severity of
                    this problem without examining the code in-situ.  The
                    code should be inspected to ensure that the intended test
                    is occurring.
                </p>
				<p>
                    Accuracy:  This warning is always indicates
                    possible confusion in the use of an operator or operator
                    precedence. 
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int x, int y)">
				<defectiveSrc><![CDATA[
                    if (!x & y) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    /* When testing that x has no bits in common with y. */

                    if (!(x & y)) {;}


                    /* When testing for the complement of x in y. */

                    if ((~x) & y) {;}


                    /* When y is a Boolean or Boolean result. */

                    if ((!x) && y) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- PossibleArithmeticBoolConflict -->
		<DefectDef guid="dda70ba1-d8f0-4ae0-b4f9-0eaf2df9b636" id="291" name="LogicalNotBitwiseOr">
			<description>
				<format>
                    Bitwise operation on logical result
                </format>
			</description>
			<additionalInfo>
				<format>
                    ! has higher precedence than |
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Use || or (!(x | y)) instead
                </format>
			</recommendedFix>
			<doc>
				<p>
                    The <code>!</code> operator yields a Boolean result, and
                    the <code>|</code> (bitwise-or) operator takes two
                    arithmetic arguments.  The <code>!</code> operator also
                    has higher precedence than <code>|</code>.
                </p>
				<p>
                    Therefore one of the following errors has been detected:
                    <ul>
						<li>
                            The expression is mis-parenthesised:
                            <ul>
                                Since the result of <code>!</code> is
                                Boolean (zero or one), an attempt to test
                                that two variables have bits set will
                                only end up testing that the lowest bit is
                                present in the right-hand-side:  <code>((!x)
                                | y) != (!(x | y))</code> when <code>x ==
                                0</code> and <code>y == 1</code>.
                            </ul>
						</li>
						<li>
                            The <code>!</code> operator is incorrect, and
                            should be a <code>~</code> instead:
                            <ul>
                                The <code>!</code> operator has a Boolean
                                result, while the <code>~</code> operator
                                has an arithmetic result.  These operators
                                are only interchangeable when operating on a
                                Boolean value (zero or one):  <code>((!x) |
                                y) != ((~x) | y)</code>) when <code>x ==
                                1</code> and <code>y == 0</code>.
                            </ul>
						</li>
						<li>
                            The binary operator <code>|</code> is incorrect,
                            and should instead be <code>||</code>:
                            <ul>
                                While <code>|</code> can sometimes be
                                interchanged with <code>||</code>, it is
                                neither equivalent nor efficient as it
                                forces evaluation of the right-hand-side of
                                the expression.  Certain side-effects in
                                this sort of expression can be terminal:
                                <code>(!p | (*p == '\0'))</code>, when
                                <code>p == NULL</code>, we must dereference
                                it to evaluate the other half of the
                                expression.
                            </ul>
						</li>
					</ul>
				</p>
				<p>
                    This warning is not reported if the <code>!</code>
                    operator is on the left-hand-side of the <code>|</code>
                    operator as this case is typically just the relatively
                    benign case of an incorrect operator.
                </p>
				<p>
                    Impact: It is difficult to judge the severity of
                    this problem without examining the code in-situ.  The
                    code should be inspected to ensure that the intended test
                    is occurring.
                </p>
				<p>
                    Accuracy:  This warning is always indicates
                    possible confusion in the use of an operator or operator
                    precedence. 
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int x, int y)">
				<defectiveSrc><![CDATA[
                    if (!x | y) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    /* When checking whether any bits are set in either x or y. */

                    if (!(x | y)) {;}


                    /* When checking whether bits are set in either the complement of x or in y. */

                    if ((~x) | y) {;}


                    /* When y is a Boolean or Boolean result. */

                    if ((!x) || y) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkLSHIFT -->
		<DefectDef guid="c1b9fc80-3bde-4806-b01d-4e584ac1ee38" id="297" name="ResultOfShiftCastToLargerSize">
			<description>
				<format>
                    Arithmetic overflow
                </format>
			</description>
			<additionalInfo>
				<format>
                    32-bit value is shifted, then cast to 64-bit value
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Cast to a 64-bit value before the shift
                </format>
			</recommendedFix>
			<consequence>
				<format>
                    Bits may be lost
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates incorrect behavior resulting from
                    integral promotion rules and types larger than those in
                    which arithmetic is typically performed.
                </p>
				<p>
                    In this case, a 32-bit value was shifted left, and the
                    result of that shift was cast to a 64-bit value.  If the
                    shift overflowed the 32-bit value, bits are lost.
                </p>
				<p>
                    If you don't want to loose bits, cast the value to be
                    shifted to a 64-bit quantity before it is shifted.
                </p>
				<p>
                    If you want to loose
                    bits, performing the appropriate cast (to unsigned long
                    or a shorter type), or masking the result of the shift
                    will eliminate this warning and make the intent of the
                    code more clear.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(unsigned int i)">
				<defectiveSrc><![CDATA[
                    unsigned __int64 x;

                    x = i << 34;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    unsigned __int64 x;

                    x = ((unsigned __int64)i) << 34;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="f0e67291-ef50-4d2e-b919-1c7d309ba428" id="308" name="ReallocLeak">
			<description>
				<format>
                    Leaking memory
                </format>
			</description>
			<additionalInfo>
				<format>
                    if memory allocation fails, the pointer to allocated
                    memory (%pointer%) will be clobbered by %function%'s
                    return value of NULL
                </format>
				<param name="pointer" format="%ls"/>
				<param name="function" format="%ls"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates a memory leak resulting from the
                    incorrect use of a reallocation function.
                </p>
				<p>
                    Heap reallocation functions do not free the passed
                    buffer if reallocation is unsuccessful, but
                    PRE<i>f</i>ast has detected that the original pointer is
                    overwritten with the result of the reallocation call.
                </p>
				<p>
                    Assign the result of the reallocation function to a
                    temporary, then replace the original pointer after
                    successful reallocation.
                </p>
				<p>
                    This warning may generate noise if there is a live alias
                    to the buffer-to-be-reallocated at the time of the
                    assignment of the result of the reallocation function.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%()" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    char *x;

                    x = (char *)malloc(10);

                    if (x) {
                        x = (char *)realloc(x,
                                            512);
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char *x, *tmp;

                    x = (char *)malloc(10);

                    if (x) {
                        tmp = (char *)realloc(x,
                                              512);

                        if (tmp != NULL) {
                            x = tmp;
                        }

                        free(x);
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- -->
		<!-- WalkTRYEXCEPT -->
		<DefectDef guid="230602de-119b-4cb7-b3fc-05bde1459c1d" id="310" name="IllegalExceptExprConst">
			<description>
				<format>
                    Illegal constant in exception filter
                </format>
			</description>
			<question>
				<format>
                    Did you intend to test this constant against
                    <code>GetExceptionCode()</code>
				</format>
			</question>
			<doc>
				<p>
                    This warning indicates that an illegal constant was
                    detected in the filter expression of an structured
                    exception handler.
                </p>
				<p>
                    The constants defined for use in the filter expression
                    of a structured exception handler are:

                    <ul>
						<li>
							<code>EXCEPTION_CONTINUE_EXECUTION</code>
						</li>
						<li>
							<code>EXCEPTION_CONTINUE_SEARCH</code>
						</li>
						<li>
							<code>EXCEPTION_EXECUTE_HANDLER</code>
						</li>
					</ul>

                    These values are defined in the C-runtime header
                    except.h.
                </p>
				<p>

                    Using a constant not in the above list can lead to
                    unexpected behavior.  In the example shown below, use of
                    <code>EXCEPTION_ACCESS_VIOLATION</code> in the filter
                    expression is treated as
                    <code>EXCEPTION_CONTINUE_EXECUTION</code>.  This leads
                    to the following behavior:

                    <ul>
						<li>
                            If the exception is triggered by the call to
                            <code>RaiseException</code>, execution will
                            continue after the exception and actually write
                            at the out-of-range address.
                        </li>
						<li>
                            If an exception is occurs because
                            <code>Handle</code> is an invalid pointer, an
                            infinite loop will result, as execution is
                            continued at the instruction that resulted in
                            the exception (resulting in another exception
                            that is handled the same way, thus an
                            infinite loop).
                        </li>
					</ul>                        

                    In either case, the actual handler statement will never
                    be executed.  The return statement is dead code.
                </p>
			</doc>
			<example funcBody="int Precedence_%id%(HANDLE *Handle, HANDLE NewValue)" sysIncludes="winbase.h">
				<defectiveSrc><![CDATA[
                    #define LIMIT   0x7fff0000

                    __try {

                        if (Handle >= Limit) {
                            RaiseException(EXCEPTION_ACCESS_VIOLATION);
                        }

                        *Handle = NewValue;

                    } __except (EXCEPTION_ACCESS_VIOLATION) {
                        return EXCEPTION_ACCESS_VIOLATION;
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    #define LIMIT   0x7fff0000

                    __try {

                        if (Handle >= Limit) {
                            RaiseException(EXCEPTION_ACCESS_VIOLATION);
                        } 

                        *Handle = NewValue;

                    } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) {
                        return EXCEPTION_ACCESS_VIOLATION;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkTRYEXCEPT -->
		<DefectDef guid="d5d82775-0b47-4fdd-bd99-4a637a9f164f" id="312" name="ExceptionContinueExecution">
			<description>
				<format>
                    Possible infinite loop
                </format>
			</description>
			<additionalInfo>
				<format>
                    use of the constant
                    <code>EXCEPTION_CONTINUE_EXECUTION</code> in the
                    exception-filter expression of a <code>try-except</code>
				</format>
			</additionalInfo>
			<consequence>
				<format>
                    Execution restarts in the protected block
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that PRE<i>f</i>ast has detected
                    the use of the constant
                    <code>EXCEPTION_CONTINUE_EXECUTION</code> (or another
                    constant that evaluates to -1) in the filter expression
                    of a structured exception handler.
                </p>
				<p>
                    Use of the constant value
                    <code>EXCEPTION_CONTINUE_EXECUTION</code> can lead to an
                    infinite loop.  If an exception was raised by hardware,
                    the instruction that cause the exception will be
                    resarted.  If the address which caused the exception is
                    still bad, another exception will occur, and be handled
                    in the same way.  This results in an infinte loop.
                </p>
				<p>
                    An explicit call to <code>RaiseException</code> will not
                    directly result in an infinite loop, but it will
                    continue execution of the code in the protected block.
                    This can be unexpected, and can lead to an infinite loop
                    if <code>RaiseException</code> was used to avoid
                    dereferencing an invalid pointer.
                </p>
				<p>
                    In addition, when
                    <code>EXCEPTION_CONTINUE_EXECUTION</code> is used, the
                    handler block of the structured exception handler is not
                    executed.
                </p>
				<p>
					<code>EXCEPTION_CONTINUE_EXCEPTION</code> should
                    typically only be returned by a function called in the
                    filter expression, which has a chance to fix either the
                    pointer that caused the exception, or the underlying
                    memory.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%">
				<defectiveSrc><![CDATA[
                    __try {
                        *ptr = '\0';
                    } __except (EXCEPTION_CONTINUE_EXCEPTION) {
                        // This block is never executed

                        ;
                    }
                            
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    __try {
                        *ptr = '\0';
                    } __except (ExceptionFilter(ptr, GetExceptionCode())) {
                        // Block may be executed depending on result of call
                        // to ExceptionFilter.

                        ;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- DetectBitwiseCollusion -->
		<DefectDef guid="85410e47-35b3-4372-94f1-0170c017212f" id="313" name="BitAndVSZeroValuedFlag">
			<description>
				<format>
                    Incorrect operator
                </format>
			</description>
			<additionalInfo>
				<format>
                    zero-valued flag cannot be tested with bitwise-and
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Use an equality test to check for zero-valued flags
                </format>
			</recommendedFix>
			<doc>
				<p>
                    This warning indicates that a constant value of zero 
                    was provided as an argument to the bitwise-and
                    (<code>&amp;</code>) operator in a test context.
                </p>
				<p>
                    The resulting expression is constant and evaluates to
                    false.
                </p>
				<p>

                    This is typically caused by using bitwise-and to test
                    for a flag that has the value zero.  In order to test
                    zero-valued flags, a test for equality must be performed
                    (e.g. using <code>==</code> or <code>!=</code>).
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int Flags)" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    #define FLAG    0

                    if (Flags &amp; FLAG) {
                        ;
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    #define FLAG    0

                    if (Flags == FLAG) {
                        ;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- DetectBitwiseCollusion -->
		<DefectDef guid="4ee408af-e42f-4593-85ae-f3bf95e3d51c" id="314" name="BitOrVSQuestion">
			<description>
				<format>
                    Incorrect order of operations
                </format>
			</description>
			<additionalInfo>
				<format>
                    bitwise-or has higher precedence than the
                    conditional-expression operator
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Add parenthesies to clarify intent
                </format>
			</recommendedFix>
			<doc>
				<p>
                    This warning indicates that an expression containing a
                    bitwise-or operator (<code>|</code>) against a non-zero
                    constant was detected in the tested expression of a
                    conditonal-expression operation (<code>?:</code>).  The
                    tested expression is constant and always true.
                </p>
				<p>
                    The conditional-expression operator
                    has lower precedence than bitwise operations.  If the
                    expression to be tested should not contain the
                    bitwise-or operator, add parenthesies
                    around the conditional-expression.
                </p>
			</doc>
			<example funcBody="int Precedence_%id%(int i)">
				<defectiveSrc><![CDATA[
                    return 7 | i ? true : false;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    return 7 | (i ? true : false);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- DetectBitwiseCollusion -->
		<DefectDef guid="7b86c520-c01a-4254-9693-0e61a3cc5e83" id="315" name="BitOrVSBitAnd">
			<description>
				<format>
                    Incorrect order of operations
                </format>
			</description>
			<additionalInfo>
				<format>
                    bitwise-and has higher precedence than bitwise-or
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Add parenthesies to clarify intent
                </format>
			</recommendedFix>
			<doc>
				<p>
                    This warning is flagged when an expression is detected
                    in a test context which contains both bitwise-and
                    (<code>&amp;</code>) and bitwise-or (<code>|</code>)
                    operations but results in a constant because the
                    bitwise-or operation happens last.
                </p>
				<p>
                    Parenthesies should be added to clarify inntet.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int i)">
				<defectiveSrc><![CDATA[
                    if (i &amp; 2|4)
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (i &amp; (2|4))
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- DetectBitwiseCollusion -->
		<DefectDef guid="80368ab0-2515-4f5b-9cc1-5b3e8abc93dd" id="316" name="InappropriateUseOfBitOr">
			<description>
				<format>
                    Incorrect operator
                </format>
			</description>
			<additionalInfo>
				<format>
                    tested expression is constant and non-zero
                </format>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Use bitwise-and to determine whether bits are set
                </format>
			</recommendedFix>
			<doc>
				<p>
                    This warning indcates code where bitwise-or
                    (<code>|</code>) was used when bitwise-and
                    (<code>&amp;</code>) should have been used.
                </p>
				<p>
                    Bitwise-or adds bits to the resulting expression, while
                    bitwise-and selects only those bits in common between
                    its two operators.
                </p>
				<p>
                    Tests for flags must be performed with bitwise-and or
                    an test of equality.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int Flags)">
				<defectiveSrc><![CDATA[
                    if (Flags | 8)
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (Flags &amp; 8)
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- DetectBitwiseCollusion -->
		<DefectDef guid="26892640-561b-465c-8f5d-450f18ec73dc" id="317" name="NotNotComplement">
			<description>
				<format>
                    Incorrect operator
                </format>
			</description>
			<additionalInfo>
				<format>
                    logical-not (<code>!</code>) is not interchangeable with
                    ones-complement (<code>~</code>)
                </format>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that PRE<i>f</i>ast detected
                    logical-not (<code>!</code>) being applied to a constant
                    likely to be a bit-flag.
                </p>
				<p>
                    The result of logical-not is boolean, it is incorrect to
                    apply the bitwise-and (<code>&amp;</code>) operator to a
                    boolean value.
                </p>
				<p>
                    Use the ones-complement (<code>~</code>) operator to
                    flip flags.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int a)">
				<defectiveSrc><![CDATA[
                    #define FLAGS   0x4004

                    if (a & !FLAGS) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    #define FLAGS   0x4004

                    if (a & ~FLAGS) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkTRYEXCEPT -->
		<DefectDef guid="4b6c65bb-966e-43d6-9c94-6dfd20d316f3" id="318" name="ExceptionContinueSearch">
			<description>
				<format>
                    Degenerate __try/__except
                </format>
			</description>
			<additionalInfo>
				<format>
                    use of the constant
                    <code>EXCEPTION_CONTINUE_SEARCH</code> (or another
                    constant that evaluates to zero) in the exception-filter
                    expression of a structured exception handler
                </format>
			</additionalInfo>
			<consequence>
				<format>
                    The exception is not handled, and any code in the
                    handler block is dead
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that PRE<i>f</i>ast has detected a
                    degenerate structured exception handler.
                </p>
				<p>
                    If an exception occurs in the protected block of this
                    structured exception handler, the exception will not be
                    handled because the constant
                    <code>EXCECPTION_CONTINUE_SEARCH</code> is used in the
                    exception filter expression.  Also, the handler block is
                    not executed.
                </p>
				<p>
                    This code is equivalent to the protected block without
                    the structured exception handler or handler block.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int *a)">
				<defectiveSrc><![CDATA[
                    __try {
                        *a = 0;
                    } __except (EXCEPTION_CONTINUE_SEARCH) {
                        return GetExceptionCode();
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    *a = 0;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- CheckBooleanContex -->
		<DefectDef guid="5533e841-6486-46fe-a10a-121ea912f62f" id="319" name="IgnoredByComma">
			<description>
				<format>
                    Dead code
                </format>
			</description>
			<additionalInfo>
				<format>
                    Use of the comma-operator in a tested expression causes
                    the left argument to be ignored when it has no
                    side-effects
                </format>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that PRE<i>f</i>ast has detected
                    an ignored sub-expression in test context due to the use
                    of the comma-operator (<code>,</code>).
                </p>
				<p>
                    The result of the comma-operator is the last expression
                    evaluated and arguments are evaluated left-to-right.
                </p>
				<p>
                    The expression has no influence on the tested
                    expression.  If the left expression to comma-operator
                    has no side-effects, the compiler may omit code
                    generation for the expression.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(int *x)">
				<defectiveSrc><![CDATA[
                    for (int i = 0; x[i] != NULL, x[i] < 42; i++) {;}
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    for (int i = 0; (x[i] != NULL) && (x[i] < 42); i++) {;}
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="4e15b9be-76be-4ae0-ab24-47244a589d19" id="331" name="VirtualFreeInvalidParam1">
			<description>
				<format>
                    Invalid parameter
                </format>
			</description>
			<additionalInfo>
				<format>
                    Passing <code>MEM_RELEASE</code> and
                    <code>MEM_DECOMMIT</code> in conjunction to
                    <code>%function%</code> is not allowed
                </format>
				<param name="function" format="%ls"/>
			</additionalInfo>
			<consequence>
				<format>
                    This results in the failure of this call
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that PRE<i>f</i>ast has found an
                    invalid parameter being passed to
                    <code>VirtualFree</code> or <code>VirtualFreeEx</code>.
                </p>
				<p>
					<code>VirtualFree</code> and <code>VirtualFreeEx</code>
                    both reject the flags <code>(MEM_RELEASE |
                    MEM_DECOMMIT)</code> in combination.
                </p>
				<p>
                    MSDN documentation for <code>VirtualFree</code>
                    describes its <code>dwFreeType</code> parameter as
                    follows: 

                    <ul>
						<i>"[in] Type of free operation. This parameter can
                        be <b><u>one</u></b> of the following values."</i>
                        [ The values being <code>MEM_DECOMMIT</code> and
                        <code>MEM_RELEASE</code>. ]
                    </ul>

                    Thus, the values <code>MEM_DECOMMIT</code> and
                    <code>MEM_RELEASE</code> may not be used together in the
                    same call.
                </p>
				<p>
                    It is not necessary for the decommit and release to
                    happen as independent steps.  Releasing committed memory
                    will decommit the pages as well.
                </p>
				<p>
                    Also, ensure that the return value of this function is
                    not ignored.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    VirtualFree(NULL,
                                0,
                                MEM_DECOMMIT | MEM_RELEASE);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    VirtualFree(NULL,
                                0,
                                MEM_RELEASE);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="e84710c2-9383-4264-86d2-43dfd03d2cbd" id="332" name="VirtualFreeInvalidParam2">
			<description>
				<format>
                    Invalid parameter
                </format>
			</description>
			<additionalInfo>
				<format>
                    Passing zero as the <code>dwFreeType</code> parameter to
                    <code>%function%</code> is not allowed
                </format>
				<param name="function" format="%ls"/>
			</additionalInfo>
			<consequence>
				<format>
                    This results in the failure of this call
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that PREfast has found an invalid
                    parameter being passed to <code>VirtualFree</code> or
                    <code>VirtualFreeEx</code>.
                </p>
				<p>
					<code>VirtualFree</code> and <code>VirtualFreeEx</code>
                    both reject a <code>dwFreeType</code> parameter of zero.
                </p>
				<p>
                    MSDN documentation for <code>VirtualFree</code>
                    describes its <code>dwFreeType</code> parameter as
                    follows:

                    <ul>
						<i>"[in] Type of free operation. This parameter can
                        be <b><u>one of the following</u></b> values."</i>
                        [ The values being <code>MEM_DECOMMIT</code> and
                        <code>MEM_RELEASE</code>. ]
                    </ul>

                    Thus, the values <code>MEM_DECOMMIT</code> and
                    <code>MEM_RELEASE</code> may not be used together in the
                    same call, but neither is zero a valid option.
                </p>
				<p>
                    Also, ensure that the return value of this function is
                    not ignored.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    VirtualFree(NULL,
                                0,
                                0);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    VirtualFree(NULL,
                                0,
                                MEM_RELEASE);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkFUNCTIONCALL -->
		<DefectDef guid="43b09cd5-667c-4b58-a137-3f5881c67d6d" id="333" name="VirtualFreeInvalidParam3">
			<description>
				<format>
                    Invalid parameter
                </format>
			</description>
			<additionalInfo>
				<format>
                    Passing MEM_RELEASE and a non-zero dwSize parameter to
                    <code>%function%</code> is not allowed
                </format>
				<param name="function" format="%ls"/>
			</additionalInfo>
			<consequence>
				<format>
                    This results in the failure of this call
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that PREfast has found an invalid
                    parameter being passed to <code>VirtualFree</code> or
                    <code>VirtualFreeEx</code>.
                </p>
				<p>
					<code>VirtualFree</code> and
                    <code>VirtualFreeEx</code> both reject a dwFreeType of
                    <code>MEM_RELEASE</code> when a non-zero value of
                    <code>dwSize</code> is also passed.
                </p>
				<p>
                    MSDN documentation for <code>VirtualFree</code>'s dwSize
                    parameter includes the following text:

                    <ul>
						<i>"If the dwFreeType parameter is MEM_RELEASE, this
                        parameter must be zero. The function frees the
                        entire region that was reserved in the initial
                        allocation call to <b>VirtualAlloc</b>."</i>
					</ul>

                    Thus when passing <code>MEM_RELEASE</code>, the
                    <code>dwSize</code> parameter must be zero.
                </p>
				<p>
                    Also, ensure that the return value of this function is
                    not ignored.
                </p>
			</doc>
			<example funcBody="void Precedence_%id%(DWORD RegionSize)" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    VirtualFree(NULL,
                                RegionSize,
                                MEM_RELEASE);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    VirtualFree(NULL,
                                0,
                                MEM_RELEASE);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!--  -->
		<!-- WalkUMINUS -->
		<DefectDef guid="f0db6a75-7021-42ce-acaa-274a0f37ea16" id="334" name="SizeofExpr">
			<description>
				<format>
                    The sizeof operator applied to an expression with an
                    operator may yield unexpected results
                </format>
			</description>
			<doc>
				<p>
                    This warning indicates that PRE<i>f</i>ast has detected
                    a misuse of the <code>sizeof</code> operator.
                </p>
				<p>
                    The <code>sizeof</code> operator, when applied to an
                    expression yields the size of the type of the resulting
                    expression.
                </p>
				<p>
                    For example, in the following code:
                </p>
				<pre>
                    char                    a[10];
                    size_t                  x;

                    x = sizeof (a + 1);
                </pre>
				<p>
					<code>x</code> will be assigned the value 4, not 9
                    because the resulting no longer a pointer to the array
                    a, but simply a pointer.
                </p>
			</doc>
			<example funcBody="int Precedence_%id%">
				<defectiveSrc><![CDATA[
                    char    a[10];

                    return sizeof (a + 4);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char    a[10];

                    return sizeof (a) - 4;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
	</DefectDefGroup>
	<DefectDefGroup guid="B824CD66-F317-4970-B9BA-ED758A2028CD" id="500" name="ShellGuide">
		<display>Windows Shell Team Guidelines</display>
		<doc>
			<P>Coding guidelines for the Windows Shell Team.</P>
		</doc>
		<ownerURL>http://badapi</ownerURL>
		<ownerContact>hunterh</ownerContact>
		<!-- //////////////////////////////////////////////////////////////// -->
		<!-- 500 -->
		<DefectDef guid="494AA452-2B30-4078-8B70-7B4EFAFB9472" id="501" name="AVOID_BLOCKING_HWNDBROADCAST">
			<description>
				<format>Avoid blocking on HWND_BROADCAST</format>
			</description>
			<additionalInfo>
				<format>prefer SendMessageTimeout with a timeout less than 1 sec or PostMessage</format>
			</additionalInfo>
			<helpURL>http://badapi/501.htm</helpURL>
		</DefectDef>
		<DefectDef guid="ab5f5590-06bf-4a0a-8e58-e1c19adcb8cc" id="502" name="AVOID_TIMEOUT_HWNDBROADCAST">
			<description>
				<format>Avoid calling SendMessageTimeout with HWND_BROADCAST</format>
			</description>
			<helpURL>http://badapi/502.htm</helpURL>
		</DefectDef>
		<DefectDef guid="CC8FE822-4570-44E6-A706-72018054600F" id="503" name="CheckForTruncation">
			<description>
				<format>Truncation not checked</format>
			</description>
			<helpURL>http://badapi/503.htm</helpURL>
		</DefectDef>
		<DefectDef guid="4b96dab7-00d5-4208-9bc4-f036d1815cc4" id="504" name="AVOID_SENDMESSAGE_TIMEOUT_MISUSE">
			<description>
				<format>Avoid calling SendMessageTimeout with SMTO_ABORTIFHUNG with a timeout of 0</format>
			</description>
			<helpURL>http://badapi/504.htm</helpURL>
		</DefectDef>
		<DefectDef guid="20559e50-1d87-43f4-b8f4-d7075c6a7949" id="505" name="HRESULT_FROM_WIN32_WITH_FUNCTION">
			<description>
				<format>Avoid calling HRESULT_FROM_WIN32 with a function(%function%) as a parameter</format>
				<param name="function" format="%s"/>
			</description>
			<helpURL>http://badapi/505.htm</helpURL>
		</DefectDef>
		<DefectDef guid="7025bcbb-4c06-4f4a-a59e-ff3a1fead7f8" id="506" name="PREFER_PathFileExistsAndAttributes">
			<description>
				<format>Prefer PathFileExistsAndAttributes over GetFileAttributes</format>
			</description>
			<helpURL>http://badapi/506.htm</helpURL>
		</DefectDef>
		<DefectDef guid="36fcbbd6-782e-4ee1-8f48-9b52333a3622" id="507" name="PREFER_DefaultStackSize">
			<description>
				<format>Prefer using default stack size over passing in hard-coded value</format>
			</description>
			<helpURL>http://badapi/507.htm</helpURL>
		</DefectDef>
		<DefectDef guid="12160541-21fa-46cd-996e-c1e96f0b94f1" id="508" name="SETWINDOWPOS_MISUSE1">
			<description>
				<format>If SWP_NOZORDER flag is set - then hWndInsertAfter should be NULL</format>
			</description>
			<helpURL>http://badapi/508.htm</helpURL>
		</DefectDef>
		<DefectDef guid="bafa7227-a2d2-48b1-99ab-6eca3a8c46cb" id="509" name="SETWINDOWPOS_MISUSE2">
			<description>
				<format>If SWP_NOMOVE flag is set - then the x/y paramaters should be NULL</format>
			</description>
			<helpURL>http://badapi/509.htm</helpURL>
		</DefectDef>
		<DefectDef guid="63d5b969-1b4f-43dd-9ab3-fecde9aafb99" id="510" name="SETWINDOWPOS_MISUSE3">
			<description>
				<format>If SWP_NOSIZE flag is set - then the cx/cy paramaters should be NULL</format>
			</description>
			<helpURL>http://badapi/510.htm</helpURL>
		</DefectDef>
		<DefectDef guid="45ae5693-daa6-4f6a-9bf5-0e76a42e317f" id="511" name="PREFER_StrCatBuff">
			<description>
				<format>"Prefer StrCatBuff over lstrcatn"</format>
			</description>
			<helpURL>http://badapi/511.htm</helpURL>
		</DefectDef>
		<DefectDef guid="a8acc8e7-cca7-46f3-a2ea-1c3e4fa59ad2" id="512" name="OBSOLETE_FUNCTION">
			<description>
				<format>Using obsolete function '%oldfunction%', prefer '%newfunction%'</format>
				<param name="oldfunction" format="%s"/>
				<param name="newfunction" format="%s"/>
			</description>
			<helpURL>http://badapi/512.htm</helpURL>
		</DefectDef>
		<DefectDef guid="4749a3f3-6d1c-4ce0-a1a3-5213484b1b3a" id="513" name="AVOID_COMPLEX_DLLMAIN">
			<description>
				<format>Avoid complex initialization in DllMain</format>
			</description>
			<helpURL>http://badapi/513.htm</helpURL>
		</DefectDef>
		<DefectDef guid="8FC87312-15D6-46cc-87EB-8A9EC79F6F0C" id="514" name="CREATEFILEMAPPING_MISUSE1">
			<description>
				<format>Potential for unauthorized access to named file mapping, prefer unnamed mapping and set appropriate security attributes</format>
			</description>
			<helpURL>http://badapi/514.htm</helpURL>
		</DefectDef>
		<DefectDef guid="71332CBF-EAED-4bcb-8BE9-CA5F40111DDB" id="515" name="ALLOCA_RESETSTKOFLW">
			<description>
				<format>must call _resetstkoflw in the catch block when calling _alloca in the try block</format>
			</description>
			<helpURL>http://badapi/515.htm</helpURL>
		</DefectDef>
		<DefectDef guid="5F09C992-BF5F-4657-815B-5635BD734ADE" id="516" name="INTERLOCKEDDECREMENT_MISUSE1">
			<description>
				<format>Multithreaded AV condition</format>
			</description>
			<additionalInfo>
				<format>After InterlockedDecrement(`this`.m_cRef) you can't reference member variables again - they may be deleted already</format>
			</additionalInfo>
			<helpURL>http://badapi/516.htm</helpURL>
		</DefectDef>
		<DefectDef guid="7bc8a712-2117-40ee-97c4-18005049fe7b" id="517" name="AVOID_BEGIN_THREAD_RETURN_VALUE">
			<description>
				<format>Avoid using the return value of _beginthread().  Use _beginthreadex() instead</format>
			</description>
			<helpURL>http://badapi/517.htm</helpURL>
		</DefectDef>
		<DefectDef guid="06448c7c-3181-4fd2-a42b-884730600204" id="518" name="COM_OBJECT_DESTRUCTOR">
			<description>
				<format>Object goes out of scope after call to CoUninitialize(), bug if object destructor uses COM</format>
			</description>
			<helpURL>http://badapi/518.htm</helpURL>
		</DefectDef>
		<DefectDef guid="71332CBF-EAED-4bcb-8BE9-CA5F40111DD0" id="519" name="CATCH_ALL">
			<description>
				<format>masking AV</format>
			</description>
			<additionalInfo>
				<format>report these bugs to fault logging tools instead?</format>
			</additionalInfo>
			<helpURL>http://badapi/519.htm</helpURL>
		</DefectDef>
		<DefectDef guid="eeab12b8-0cd9-4b41-be1b-fa334cf5f161" id="520" name="HEAP_BUFFER_OVERFLOW">
			<description>
				<format>[NOISY] Buffer Overflow</format>
			</description>
			<additionalInfo>
				<format>BufferSize Param%param1%(%number1% bytes) for Param%param2%(%number2% bytes)?</format>
				<param name="param1" format="%d" display=""/>
				<param name="number1" format="%d" display=""/>
				<param name="param2" format="%d" display=""/>
				<param name="number2" format="%d" display=""/>
			</additionalInfo>
			<helpURL>http://badapi/520.htm</helpURL>
		</DefectDef>
		<DefectDef guid="8563dd32-208e-4568-a1e8-ad357cfec0bc" id="521" name="MEMSET_ZEROMEMORY">
			<description>
				<format>prefer ZeroMemory over memset(0)</format>
			</description>
			<additionalInfo>
				<format>ZeroMemory is more readable code</format>
			</additionalInfo>
			<helpURL>http://badapi/521.htm</helpURL>
		</DefectDef>
		<DefectDef guid="44b5c1c6-40e3-460a-bbc2-5fe572263f8a" id="523" name="UNSIGNED_CAST_OF_GETMESSAGEPOS">
			<description>
				<format>Unsigned cast of GetMessagePos() coordinates.  Use GET_X_LPARAM/GET_Y_LPARAM instead of LOWORD/HIWORD</format>
			</description>
			<additionalInfo>
				<format>GetMessagePos() coordinates may be negative on multi-monitor systems</format>
			</additionalInfo>
			<helpURL>http://badapi/523.htm</helpURL>
		</DefectDef>
		<DefectDef guid="2512985c-955a-4cd2-871b-c90a65ce7ca8" id="524" name="UNRELEASED_REF">
			<description>
				<format>No call to Release() to match incremented refcount from LResultFromObject</format>
			</description>
			<additionalInfo>
				<format>LresultFromObject() increases the refcount on new IAccessible objects</format>
			</additionalInfo>
			<helpURL>http://badapi/524.htm</helpURL>
		</DefectDef>
		<DefectDef guid="FD803F3C-44F1-4c34-841F-29A66CABDB6D" id="525" name="COMPILER_OPTIMIZATES_OUT_CLEARING_SENSITIVEDATA">
			<description>
				<format>The call may be optimized out during compile, resulting in sensitive data
                        lingering in memory.  Use SecureZeroMemory or RtlSecureZeroMemory instead</format>
			</description>
			<helpURL>http://badapi/525.htm</helpURL>
		</DefectDef>
		<DefectDef guid="3bb6eaa0-af7a-4dae-9537-8ddc50d77afc" id="526" name="AVOID_PROPVARIANT_VARIANT_CASTS">
			<description>
				<format>Avoid casts between PROPVARIANT and VARIANT; use VariantToPropVariant and PropVariantToVariant instead</format>
			</description>
			<helpURL>http://badapi/526.htm</helpURL>
		</DefectDef>
		<DefectDef guid="1d86f604-5973-41d2-a103-20a4239aa74f" id="527" name="DEACTIVATECONTEXT_OUTSIDE_FINALLY">
			<description>
				<format>Calls to SHDeactivateContext, DeactivateActCtx, and NT5_DeactivateActCtx should be inside __finally blocks</format>
			</description>
			<helpURL>http://badapi/527.htm</helpURL>
		</DefectDef>
		<DefectDef guid="c3c8c213-4f50-4db8-824a-b5714e375c2e" id="528" name="AVOID_EXT_TEXT_OUT_CALL">
			<description>
				<format>ExtTextOut is a bad API to call.  Use SHExtTextOut() instead</format>
			</description>
			<additionalInfo>
				<format>ExtTextOut is a bad API to call. This will be broken on Hebrew builds. Use SHExtTextOut instead</format>
			</additionalInfo>
			<helpURL>http://badapi/528.htm</helpURL>
		</DefectDef>
		<DefectDef guid="6560e70b-8e97-475d-b65e-582d32b84eb5" id="529" name="AVOID_MUTABLE_VALUE_VARIANT">
			<description>
				<format>%argName% was passed into this function by value and then modified.  VARIANTs and VARIANTARGs must be copied with VariantCopy.  Passing by value uses a bitwise copy, which is incorrect for many variant types</format>
				<param name="argName" format="%s"/>
			</description>
			<additionalInfo>
				<format>Function declarations should be: DoSomething(VARIANT *pvt)</format>
			</additionalInfo>
			<helpURL>http://badapi/529.htm</helpURL>
		</DefectDef>
		<DefectDef guid="66ab5d8f-e14f-4e54-9513-cd79ae38c52f" id="531" name="CAST_64STAR_TO_32STAR">
			<description>
				<format>Cast between pointers to incompatible sized integers on 64-bit platform</format>
			</description>
			<additionalInfo>
				<format>casting from %oldtype% * (%oldbits% bits) to %newtype% * (%newbits% bits)</format>
				<param name="oldtype" format="%s"/>
				<param name="oldbits" format="%d"/>
				<param name="newtype" format="%s"/>
				<param name="newbits" format="%d"/>
			</additionalInfo>
			<helpURL>http://badapi/531.htm</helpURL>
		</DefectDef>
		<DefectDef guid="385f42e0-3b05-45aa-8758-ea3f5faecd44" id="532" name="CAST_FFFFFFFF_TO_64BIT">
			<description>
				<format>0xFFFFFFFF used in 64-bit context.  In 64-bits, 0xFFFFFFFF != -1; consider using -1 instead</format>
			</description>
			<helpURL>http://badapi/532.htm</helpURL>
		</DefectDef>
		<DefectDef guid="88a11211-57af-4cf2-96e7-df393d94c4a3" id="535" name="MUST_CHECK_S_OK">
			<description>
				<format>Result of SHGetPropStgReadMultiple must be compared against S_OK, not just checked via SUCCEEDED()</format>
			</description>
			<helpURL>http://badapi/535.htm</helpURL>
		</DefectDef>
		<DefectDef guid="eacaf84d-855c-4a5f-93ab-4b4ab105cf34" id="536" name="LOCAL_FREE_NONALLOCATED">
			<description>
				<format>Calling LocalFree on non-allocated pointer</format>
			</description>
			<additionalInfo>
				<format>pointer initialized from call to %function% (line %lineno%)</format>
				<param name="function" format="%s"/>
				<param name="lineno" format="%d"/>
			</additionalInfo>
			<helpURL>http://badapi/536.htm</helpURL>
		</DefectDef>
		<DefectDef guid="e7177a83-ce93-4615-b7fb-46c8fc999ca5" id="537" name="UNSAFE_CALL_IN_GLOBAL_INIT">
			<description>
				<format>Calling %function% in a global initializer is unsafe</format>
				<param name="function" format="%s"/>
			</description>
			<helpURL>http://badapi/537.htm</helpURL>
		</DefectDef>
		<DefectDef guid="905e8dbf-aead-485c-b700-4313e54c12c9" id="538" name="DLOAD_FUNCDEFN">
			<description>
				<format>'%function%' delayload stub is missing a matching FUNCDECL</format>
				<param name="function" format="%s"/>
			</description>
			<helpURL>http://badapi/538.htm</helpURL>
		</DefectDef>
		<DefectDef guid="6C547F1C-23E1-4C4E-BDD9-E5B187E2A337" id="539" name="CLOSEHANDLE_STRING">
			<description>
				<format>Calling close handle with string '%badstring%'</format>
				<param name="badstring" format="%s"/>
			</description>
			<helpURL>http://badapi/539.htm</helpURL>
		</DefectDef>
		<DefectDef guid="012B16B4-90E3-4459-AA42-82DEB9A486BD" id="540" name="DLOAD_FUNCSTATIC">
			<description>
				<format>'%function%' delayload stub should be a static function.</format>
				<param name="function" format="%s"/>
			</description>
			<helpURL>http://badapi/540.htm</helpURL>
		</DefectDef>
		<DefectDef guid="bca4f552-42e4-4e36-9980-d63230f7fbac" id="541" name="LOCALREALLOC_LPTR">
			<description>
				<format>LocalReAlloc and LPTR flag is bad</format>
			</description>
			<helpURL>http://badapi/541.htm</helpURL>
		</DefectDef>
		<DefectDef guid="b215ab89-70ab-42ec-99c7-9e0033ec2585" id="542" name="BAD_POSTMESSAGE_FLAG">
			<description>
				<format>Bad flag for PostMessage</format>
			</description>
			<helpURL>http://badapi/542.htm</helpURL>
		</DefectDef>
	</DefectDefGroup>
	<DefectDefGroup guid="c1a12b07-c386-47b1-b613-f1b8919b6ea6" id="264" name="Typo">
		<display>Typo Warnings</display>
		<doc>
			<p>
                The Typo module detects problems in arguments to format
                functions, dangerous cast behavior, and mismatches between
                allocation and free functions.
            </p>
		</doc>
		<ownerURL>http://anyURL</ownerURL>
		<ownerContact>anyAlias</ownerContact>
		<!-- -->
		<DefectDef guid="e02b87ea-f172-438a-86a7-fc254b20b0f3" id="31" name="RETVAL_IGNORED_FUNC_COULD_FAIL">
			<description>
				<format>
                    Return value ignored
                </format>
			</description>
			<additionalInfo>
				<format>
                    %function% could return unexpected value
                </format>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that the calling function is not
                    checking the return value of a function call. The function
                    may signal failure via its return value, or the function
                    may simply return a value that the caller isn't expecting.
                    Depending on which function is being called, this defect
                    may lead to seemingly random program misbehavior, including
                    crashes and data corruptions in error conditions or
                    low-resource situations.
                </p>
				<p>
                    In general, it is not safe to assume that a call to
                    functions such as <code>ReadFile</code> (i.e., those that
                    access disk or network resources) or
                    <code>CoCreateInstance</code> (i.e., those that may
                    require memory or other resources to be allocated) will
                    always succeed. The caller should always check the
                    return value and handle error cases appropriately.
                </p>
				<p>
                    If you are intentionally ignoring the return value (for
                    example, in a situation where you are taking advantage
                    of a COM functions guarantee that it will initialize its
                    outputs to <code>NULL</code> if it fails), you can silence
                    PRE<i>f</i>ast by explicitly casting the return value to
                    <code>void</code>.
                </p>
			</doc>
			<example funcBody="void Typo_31(HANDLE *Pipe)" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    ImpersonateNamedPipeClient(Pipe);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (!ImpersonateNamedPipeClient(Pipe)) {
                        // Dangerous to continue

                        return;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_31.htm</helpURL>
		</DefectDef>
		<!-- -->
		<!--
        <DefectDef guid="9a0f2f5b-4088-4849-af61-4fc0131b599a"
            id="55"
            name="POTENTIALLY_UNTRUSTED_FORMAT_STRING">
            <format>Potentially untrusted format string '%ls' passed to '%ls'</format>
            <display>Potentially untrusted format string passed to '<PARAM>function</PARAM>'</display>
        </DefectDef>
-->
		<!-- -->
		<DefectDef guid="d42294ba-f3f4-418e-97cc-9e238f882188" id="63" name="MISSING_STRING_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    missing string argument to %function% corresponding to
                    conversion specifier %number%
                </format>
				<param name="function" format="'%ls'"/>
				<param name="number" format="%d"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that not enough arguments are
                    being provided to match a format string; at least one of
                    the missing arguments is a string. This defect can lead
                    to crashes and buffer overflows (if the called function
                    is of the sprintf family), as well as potentially
                    incorrect output.
                </p>
				<p>
                    This warning is often reported because of subtle errors
                    contained in format strings such as extra embedded
                    spaces or unescaped percent signs. If the warning
                    appears to be incorrect, it is probably worth
                    double-checking your format string.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library.
                </p>
			</doc>
			<example funcBody="void Typo_63" sysIncludes="stdio.h">
				<defectiveSrc><![CDATA[
                    char buff[5];

                    sprintf(buff, "%s %s", "a");
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff[5];

                    sprintf(buff, "%s %s", "a", "b");
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_63.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="a3a9924c-3523-4e6e-862a-6727332bca75" id="64" name="MISSING_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    missing integer argument to %function% corresponding to conversion specifier %number%
                </format>
				<param name="function" format="'%ls'"/>
				<param name="number" format="%d"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that not enough arguments are
                    being provided to match a format string; all the missing
                    arguments are integers. This defect can lead to
                    incorrect output although it is not likely to lead to a
                    crash.
                </p>
				<p>
                    This warning is often reported because of subtle errors
                    contained in format strings such as extra embedded
                    spaces or unescaped percent signs. If the warning
                    appears to be incorrect, it is probably worth
                    double-checking your format string.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library.
                </p>
			</doc>
			<example funcBody="void Typo_64(char *string)" sysIncludes="stdio.h;string.h">
				<defectiveSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%s %d",
                            string);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%s %d",
                            string,
                            strlen(string));
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_64.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="d3b73fdf-fe49-44c4-a76f-5908f6031a8c" id="66" name="NON_POINTER_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    non-pointer passed as parameter %number% when pointer is
                    required in call to %function%
                </format>
				<param name="number" format="%d"/>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that the format string specifies
                    that a pointer is required (e.g., a <code>%p</code> or
                    <code>%n</code> specification for <code>printf</code> or a
                    <code>%d</code> for <code>scanf</code>) but a non-pointer
                    is being passed. This defect is likely to result in a
                    crash or corruption of some form. It is also likely to
                    cause a 64-bit porting problem.
                </p>
				<p>
                    This message is often reported because an integer has
                    been used for a <code>%p</code> format instead of a
                    pointer. Using an integer in this instance is not
                    portable to 64-bit machines.
                </p>
				<p>
                    This warning may also be reported because of subtle
                    errors contained in format strings such as extra
                    embedded spaces or unescaped percent signs. If the
                    warning appears to be incorrect, it is probably worth
                    double-checking your format string.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library.
                </p>
			</doc>
			<example funcBody="void Typo_66" sysIncludes="stdio.h">
				<defectiveSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%s %n %d",
                            "a",
                            1,
                            1);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff[5];
                    int  n;

                    sprintf(buff,
                            "%s %n %d",
                            "a",
                            &n,
                            1);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_66.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="561e8c44-658f-423d-ba15-e1ba65af1ad4" id="67" name="NON_STRING_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    non-string passed as parameter %number% when string is
                    required in call to %function%
                </format>
				<param name="number" format="%d"/>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that the format string specifies
                    that a string is required (a <code>%s</code>
                    specification for <code>printf</code> or
                    <code>scanf</code>) but a non-string (e.g., an integer
                    or float) is being passed. This defect is likely to
                    result in a crash or corruption of some form.
                </p>
				<p>
                    This warning is often reported because of subtle errors
                    contained in format strings such as extra embedded
                    spaces or unescaped percent signs. If the warning
                    appears to be incorrect, it is probably worth
                    double-checking your format string.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library.
                </p>
			</doc>
			<example funcBody="void Typo_67" sysIncludes="stdio.h">
				<defectiveSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%s %s",
                            "a",
                            1);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%s %d",
                            "a",
                            1);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_67.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="d5fe217f-1864-4ac6-8fbd-9c6495865d96" id="69" name="GRATUITOUS_CALL_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Inefficient use of %function%
                </format>
				<param name="function" format="'%ls'"/>
			</description>
			<recommendedFix>
				<format>
                    Consider calling %function% instead
                </format>
				<param name="function" format="'%ls'"/>
			</recommendedFix>
			<doc>
				<p>
                    This warning indicates that a call is being made to a
                    format function in a situation where a call to some
                    other, non-format function could have been made instead.
                    Calling the non-format function is likely to be faster
                    and often safer as well.
                </p>
				<p>
                    When possible, PRE<i>f</i>ast recommends a specific
                    preferable function to call; if PRE<i>f</i>ast cannot
                    make a specific recommendation, it will simply recommend
                    calling <i>a_safer_function</i>.
                </p>
			</doc>
			<example funcBody="void Typo_69(char *ptr)" sysIncludes="stdio.h;string.h">
				<defectiveSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            ptr);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff[5];

                    strncpy(buff,
                            ptr,
                            5);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_69.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="cd619f59-afa7-493f-bc4e-b7c7f30ed94a" id="268" name="MISPARENTHESIZED_CASTS">
			<description>
				<format>
                    Incorrect order of operations
                </format>
			</description>
			<additionalInfo>
				<format>
                    (%TYPE1%)(%TYPE2%)x + y
                </format>
				<param name="TYPE1" format="&lt;TYPE1&gt;"/>
				<param name="TYPE2" format="&lt;TYPE2&gt;"/>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Probable misparenthesization of (%TYPE1%)((%TYPE2%)x + y)
                </format>
				<param name="TYPE1" format="&lt;TYPE1&gt;"/>
				<param name="TYPE2" format="&lt;TYPE2&gt;"/>
			</recommendedFix>
			<doc>
				<p>
                    This warning indicates that a complex cast expression
                    that may involve a precedence problem when performing
                    pointer arithmetic. Since casts group more closely than
                    binary operators, the result may not be what the
                    programmer intended.
                </p>
				<p>
                    In some cases, this defect may result in incorrect
                    behavior or a program crash.
                </p>
				<p>
                    In an expression such as:

                    <ul>
						<code>
                            (char *)p + offset
                        </code>
					</ul>

                    the offset is interpreted as an offset in characters;
                    however, the expression:

                    <ul>
						<code>
                            (int *)(char *)p + offset
                        </code>
					</ul>

                    is equivalent to:

                    <ul>
						<code>
                            ((int *)(char *)p) + offset
                        </code>
					</ul>

                    and so the offset is interpreted as an offset in
                    integers - in other words, it is equivalent to:

                    <ul>
						<code>
                            (int *)((char *)p + offset * sizeof (int))
                        </code>
					</ul>

                    which is not likely to be what is intended.
                </p>
				<p>
                    Depending on the relative sizes of the two types, this
                    can lead to a buffer overrun.
                </p>
			</doc>
			<example funcBody="void Typo_268(int *p, int offset_in_bytes)">
				<defectiveSrc><![CDATA[
                    int *ptr = (int *)(char *)p + offset_in_bytes;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    int *ptr = (int *)((char *)p + offset_in_bytes);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_268.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="e55357c6-254b-4ddf-ab4a-77adbecdd517" id="269" name="POINTER_DEREF_DISCARDED">
			<description>
				<format>
                    Incorrect order of operations
                </format>
			</description>
			<additionalInfo>
				<format>
                    dereference ignored
                </format>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that the result of a pointer
                    dereference is being ignored, which raises the question
                    of why the pointer is being dereferenced in the first
                    place.
                </p>
				<p>
                    The compiler will correctly optimize away the gratuitous
                    dereference. In some cases, however, this defect may
                    reflect a precedence or logic error.
                </p>
				<p>
                    One common cause for this defect is an expression
                    statement of the form:

                    <ul>
						<code>
                            *p++;
                        </code>
					</ul>
				</p>
				<p>
                    If the intent of this statement is simply to increment
                    the pointer p, the dereference is unnecessary; however,
                    if the intent is to increment the content of the
                    location that p is pointing to, the program will not
                    behave as intended:  unary operators group from right to
                    left, so this construct is interpreted as
                    <code>*(p++)</code> rather than <code>(*p)++</code>.
                </p>
			</doc>
			<example funcBody="void Typo_269(int *p)">
				<defectiveSrc><![CDATA[
                    *p++;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    (*p)++;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_269.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="f6044e4a-5574-4d58-ab84-83c9538698ff" id="270" name="MISSING_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    missing float argument to %function%
                </format>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<recommendedFix>
				<format>
                    Add a float argument corresponding to conversion specifier %number%
                </format>
				<param name="number" format="%d"/>
			</recommendedFix>
			<doc>
				<p>
                    This warning indicates that not enough arguments are
                    being provided to match a format string; at least one of
                    the missing arguments is a floating-point number. This
                    defect can lead to crashes, as well as potentially
                    incorrect output.
                </p>
				<p>
                    This warning is often reported because of subtle errors
                    contained in format strings such as extra embedded
                    spaces or unescaped percent signs. If the warning
                    appears to be incorrect, it is probably worth
                    double-checking your format string.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library.
                </p>
			</doc>
			<example funcBody="void Typo_270" sysIncludes="stdio.h">
				<defectiveSrc><![CDATA[
                    char buff [25];

                    sprintf(buff,
                            "%s %f",
                            "pi:");
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff [25];

                    sprintf(buff,
                            "%s %f",
                            "pi:",
                            3.1415);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_270.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="5318acc3-2609-4a27-a534-0fbe8c9ae586" id="271" name="EXTRA_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    extra argument passed to %function%
                </format>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<consequence>
				<format>
                    Parameter %number% is not used by the format string
                </format>
				<param name="number" format="%d"/>
			</consequence>
			<doc>
				<p>
                    This warning indicates that extra arguments are being
                    provided beyond those specified by the format string. By
                    itself, this defect will not have any visible effect
                    although it may indicate some other problems.
                </p>
				<p>
                    This warning is often reported because of subtle errors
                    contained in format strings such as extra embedded
                    spaces or unescaped percent signs. If the warning
                    appears to be incorrect, it is probably worth
                    double-checking your format string.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library
                </p>
			</doc>
			<example funcBody="void Typo_271" sysIncludes="stdio.h">
				<defectiveSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%d",
                            1,
                            2);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%d, %d",
                            1,
                            2);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_271.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="81c6f23d-d0e9-4423-a3ab-3873a461e4c7" id="272" name="NON_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    non-float passed as argument %number% when float is
                    required in call to %function%
                </format>
				<param name="number" format="%d"/>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that the format string specifies
                    that a float is required (e.g., a <code>%f</code> or
                    <code>%g</code> specification for <code>printf</code>)
                    but a non-float such as an integer or string is being
                    passed. This defect is likely to result in incorrect
                    output; however, in certain circumstances it could
                    result in a crash.
                </p>
				<p>
                    This warning is often reported because of subtle errors
                    contained in format strings such as extra embedded
                    spaces or unescaped percent signs. If the warning
                    appears to be incorrect, it is probably worth
                    double-checking your format string.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library.
                </p>
			</doc>
			<example funcBody="void Typo_272(int i)" sysIncludes="stdio.h">
				<defectiveSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%s %f",
                            "a",
                            i);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%s %i",
                            "a",
                            i);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_272.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="d10a22fb-89a1-4e9f-847f-db7bbbae95ed" id="273" name="NON_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    non-integer passed as parameter %number% when integer is
                    required in call to %function%. If a pointer value
                    is being passed, %%p should be used, not %%x, %%d or
                    any other format string because only %%p is designed to be
                    used with pointer values on 64-bit platforms
                </format>
				<param name="number" format="%d"/>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that the format string specifies
                    that an integer is required (e.g., a <code>%d</code>,
                    length or precedence specification for
                    <code>printf</code>) but a non-integer such as a float,
                    string, or struct is being passed. This defect is likely
                    to result in incorrect output.
                </p>
				<p>
                    In particular, if a pointer value is being passed,
                    %p should be used, not %x, %d or
                    any other format string because only %p is designed to be
                    used with pointer values on 64-bit platforms
                </p>
				<p>
                    This warning is often reported because of subtle errors
                    contained in format strings such as extra embedded
                    spaces or unescaped percent signs. If the warning
                    appears to be incorrect, it is probably worth
                    double-checking your format string.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library.
                </p>
			</doc>
			<example funcBody="void Typo_273(float f)" sysIncludes="stdio.h">
				<defectiveSrc><![CDATA[
                    char buff[50];

                    sprintf(buff,
                            "%*.*s",
                            f,
                            1,
                            "cool");
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff[50];

                    sprintf(buff,
                            "%*.*s",
                            (int)f,
                            1,
                            "cool");
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_273.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="9ccc928f-ac6c-4b5f-af83-23f2008f69ec" id="274" name="NON_CHAR_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    non-character passed as parameter %number% when
                    character is required in call to %function%
                </format>
				<param name="number" format="%d"/>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that the format string specifies
                    that a character is required (e.g., a <code>%c</code> or
                    <code>%C</code> specification) but a non-integer such as
                    a float, string, or struct is being passed. This defect
                    is likely to result in incorrect output.
                </p>
				<p>
                    This warning is often reported because of subtle errors
                    contained in format strings such as extra embedded
                    spaces or unescaped percent signs. If the warning
                    appears to be incorrect, it is probably worth
                    double-checking your format string.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library.
                </p>
			</doc>
			<example funcBody="void Typo_274(char *str)" sysIncludes="stdio.h">
				<defectiveSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%c",
                            str);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff[5];

                    sprintf(buff,
                            "%c",
                            str[0]);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_274.htm</helpURL>
		</DefectDef>
		<!-- -->
		<!--
        <DefectDef guid="a0e0df8d-42d7-4383-aeb1-b2a475831189"
            id="275"
            name="WCHAR_TO_CHAR_CAST">
            <format>Casting from wchar_t* to char* type</format>
        </DefectDef>
-->
		<!-- -->
		<DefectDef guid="9faf3d5b-96a9-4f86-a9cf-452c0ed3e20f" id="276" name="CHAR_TO_WCHAR_CAST">
			<description>
				<format>
                   Cast between semantically different string types
               </format>
			</description>
			<additionalInfo>
				<format>
                    char * to wchar_t *
                </format>
			</additionalInfo>
			<consequence>
				<format>
                    This will result in garbled strings and possible crashes
                    on 64-bit or BBT-enabled builds
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates a potentially incorrect cast from
                    an ANSI string <code>(char_t *)</code> to a Unicode
                    string <code>(wchar_t *)</code>.  Since Unicode strings
                    have a character size of 2 bytes, this cast may yield
                    strings that are not correctly terminated.  Using such
                    strings with the wcs* library of functions can result in
                    buffer overruns and access violations.  In addition,
                    these inconsistencies lead to stress failures when the
                    code is optimized with BBT.
                </p>
			</doc>
			<example funcBody="void Typo_276" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    LPWSTR pSrc = (LPWSTR)"a";

                    WCHAR szBuffer[2];

                    wcscpy(szBuffer,
                           pSrc);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    LPWSTR pSrc = L"a";

                    WCHAR szBuffer[100];

                    wcscpy(szBuffer,
                           pSrc);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_276.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="35A0B24C-20EB-417a-AF3D-CABA449A8E56" id="298" name="CONST_STRING_TO_WRITABLE_STRING">
			<description>
				<format>
                    Using a read-only string %pointer% as a writable string argument
                </format>
				<param name="pointer" format="'%ls'"/>
			</description>
			<consequence>
				<format>
                    This will attempt to write into static read-only memory and
                    cause random crashes
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates a potentially dangerous use of a constant
                    string as an argument to a function that may modify the contents
                    of that string. Since the compiler allocates constant strings in
                    a static read-only memory, any attempts to modify it will cause
                    access violations and random crashes.
                </p>
				<p>
                    This can be avoided by copying the constant string into a local
                    array and using the array as the argument to the function.
                </p>
			</doc>
			<example funcBody="void Typo_298" sysIncludes="windows.h" globalDecls="STARTUPINFO Si;PROCESS_INFORMATION Pi;">
				<defectiveSrc><![CDATA[
                    CreateProcessA(NULL,
                                   "MyApp.exe -?",
                                   NULL,
                                   NULL,
                                   FALSE,
                                   0,
                                   NULL,
                                   NULL,
                                   &Si,
                                   &Pi);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char szCmdLine[] = "MyApp.exe -?";

                    CreateProcessA(NULL,
                                   szCmdLine,
                                   NULL,
                                   NULL,
                                   FALSE,
                                   0,
                                   NULL,
                                   NULL,
                                   &Si,
                                   &Pi);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_298.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="c2bc8ed7-74b7-4c82-b659-00e683fab24b" id="299" name="BITFIELD_TO_BOOL_COMPARISON">
			<description>
				<format>
                    Explicitly comparing a bit field to a Boolean will yield
                    unexpected results
                </format>
			</description>
			<doc>
				<p>
                    This warning indicates an incorrect assumption that
                    booleans and bit fields are equivalent. Assigning 1 to
                    bit fields will place 1 in it's single bit. However any
                    comparison of this bit field to 1 includes an implicit
                    cast of the bit field to a signed int. This cast will
                    convert the stored 1 to a -1 and the comparison can
                    yield unexpected results.
                </p>
			</doc>
			<example funcBody="void Typo_299(struct A a)" globalDecls="struct A {int flag:1;} a;">
				<defectiveSrc><![CDATA[
                    if (a.flag == 1 /* == TRUE */) {
                        // will not execute
                        ;
                    }
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    if (a.flag) {
                        // may execute
                        ;
                    }
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_299.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="632c2d60-22b8-4683-a091-fbe374629002" id="277" name="CREATEPROCESS_ESCAPE">
			<description>
				<format>
                    Dangerous call to %function%
                </format>
				<param name="function" format="'%ls'"/>
			</description>
			<additionalInfo>
				<format>
                    NULL application name with an unquoted path
                </format>
			</additionalInfo>
			<consequence>
				<format>
                    This results in a security vulnerability if the path 
                    contains spaces
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates a potential security problem.
                    Creating processes with explicit strings for the process
                    name requires that you escape the spaces in the name.
                    Without this precaution, the code may create
                    unintentional processes. 
                </p>
				<p>
                    This warning is sometimes reported in situations where
                    the space occurs between the executable name and the
                    argument. In this case, unless the executable name is
                    fully qualified, there is likely to be a security
                    problem in that an attacker may be able to insert a
                    rogue executable with the same name earlier in the path
                    than expected.
                </p>
			</doc>
			<example funcBody="void Typo_%id%" sysIncludes="windows.h">
				<defectiveSrc><![CDATA[
                    CreateProcessA(NULL,
                                   "c:\\program files\\foo.exe arg1",
                                   NULL,
                                   NULL,
                                   FALSE,
                                   0,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    CreateProcessA(NULL,
                                   "\"c:\\program files\\foo.exe\" arg1",
                                   NULL,
                                   NULL,
                                   FALSE,
                                   0,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_%id%.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="9faf3d5b-96a9-4f86-a9cf-452c0ed3e20f" id="278" name="ARRAY_NEW_DELETE_MISMATCH">
			<description>
				<format>
                    Allocation/free mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    %variable% is allocated with array new [], but deleted
                    with scalar delete (see allocation at %location%)
                </format>
				<param name="variable" format="'%ls'"/>
				<param name="location" format="line %d of %ls"/>
			</additionalInfo>
			<consequence>
				<format>
                    Destructors will not be called
                </format>
			</consequence>
			<doc>
				<p>
                    This warning appears only in C++ code and indicates that
                    the calling function has inconsistently allocated memory
                    with the array <code>new[]</code> operator, but freed it
                    with the scalar <code>delete</code> operator. This is
                    undefined behavior according to the C++ standard and the
                    Microsoft VC++ implementation. There are at least three
                    reasons that this is likely to cause problems:

                    <ul>
						<li>
                            The constructors for the individual objects in
                            the array are invoked, but the destructors are
                            not invoked;
                        </li>
						<li>
                            If global (or class-specific) <code>operator
                            new</code> and <code>operator delete</code> are
                            not compatible with <code>operator new[]</code>
                            and <code>operator delete[]</code>, unexpected
                            results are likely to occur;
                        </li>
						<li>
                            It is always very risky to rely on undefined
                            behavior.
                        </li>
					</ul>
				</p>
				<p>
                    The exact ramifications of this defect are difficult to
                    predict. It may result in leaks (for classes with
                    destructors which perform memory de-allocation),
                    inconsistent behavior (for classes with destructors that
                    perform some semantically significant operation), or
                    memory corruptions and crashes (in situations where
                    operators have been overridden). In other cases the
                    mismatch may be unimportant, depending on the
                    implementation of the compiler and its libraries.
                    PRE<i>f</i>ast cannot always distinguish between these
                    situations.
                </p>
				<p>
                    If memory is allocated with array <code>new[]</code>, it
                    should be typically be freed with array
                    <code>delete[]</code>.
                </p>
				<p>
                    In situations where the underlying object in the array
                    is a primitive type such as int, float, enum, or
                    pointer, there are no destructors to be called.  In this
                    case, warning 283 is reported instead.
                </p>
				<p>
                    This message is often reported on character or wide
                    character arrays. In this case, unless operators are
                    being overridden there may not be any significant
                    consequences of the mismatch; rather than an active
                    defect, it may be more appropriate to treat the warning
                    as a maintenance issue.
                </p>
			</doc>
			<example funcBody="void Typo_278(int arraySize)" globalDecls="class C {;};">
				<defectiveSrc><![CDATA[
                    C *pC = new C[arraySize];

                    delete pC;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    C *pC = new C[arraySize];

                    delete[] pC;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_278.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="df8f08b8-f7fc-4da2-b1a9-2ccc8df982c9" id="279" name="NEW_ARRAY_DELETE_MISMATCH">
			<description>
				<format>
                    Allocation/free mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    %variable% is allocated with scalar new, but deleted
                    with array delete [] (see allocation at %location%)
                </format>
				<param name="variable" format="'%ls'"/>
				<param name="location" format="line %d of %ls"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning appears only in C++ code and indicates that
                    the calling function has inconsistently allocated memory
                    with the scalar new operator, but freed it with the
                    array <code>delete[]</code> operator. This is undefined
                    behavior according to the C++ standard and the Microsoft
                    VC++ implementation. There are at least three reasons
                    that this is likely to cause problems:

                    <ul>
						<li>
                            The constructors for the individual objects in
                            the array are not invoked (although the
                            destructors are);
                        </li>
						<li>
                            If global (or class-specific) <code>operator
                            new</code> and <code>operator delete</code> are
                            not compatible with <code>operator new[]</code>
                            and <code>operator delete[]</code>, unexpected
                            results are likely to occur;
                        </li>
						<li>
                            If memory is allocated with scalar new, it should
                            typically be freed with scalar delete.
                        </li>
					</ul>
				</p>
				<p>
                    The exact ramifications of this defect are difficult to
                    predict.  It may result in random behavior or crashes
                    (due to usage of uninitialized memory because
                    constructors are not invoked), or memory allocations and
                    crashes (in situations where operators have been
                    overridden). In rare cases the mismatch may be
                    unimportant. PRE<i>f</i>ast does not currently distinguish
                    between these situations.
                </p>
			</doc>
			<example funcBody="void Typo_279(int arraySize)" globalDecls="class C { ; };">
				<defectiveSrc><![CDATA[
                    C *pC = (C *)new char[arraySize * sizeof (C)];

                    delete[] pC;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    C *pC = (C *)new C[arraySize];

                    delete[] pC;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_279.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="a66bee52-5854-4b99-a4da-3886b3708a80" id="280" name="MEMORY_ALLOCATION_MISMATCH">
			<description>
				<format>
                    Allocation/free mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    %variable% is allocated with %function1%, but deleted with
                    %function2% (see allocation at %location%)
                </format>
				<param name="variable" format="'%ls'"/>
				<param name="function1" format="'%ls'" display="&lt;function&gt;"/>
				<param name="function2" format="'%ls'" display="&lt;function&gt;"/>
				<param name="location" format="line %d of %ls"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that the calling function has
                    inconsistently allocated memory with a function from one
                    memory allocation family and freed it with a function
                    from another memory allocation family.
                </p>
				<p>
                    For example, this warning would be produced if memory is
                    allocated with <code>malloc</code> but freed with
                    <code>GlobalFree</code> or <code>delete</code>. Note that
                    in the specific cases of mismatches between array
                    <code>new[]</code> and scalar <code>delete</code> (or vice
                    versa) the more precise warnings 278, 279, or 283 are
                    reported instead.
                </p>
				<p>
                    Different API definitions may use different heaps
                    (<code>GlobalAlloc</code> uses system heap, and
                    <code>free</code> uses C heap for example) and the
                    allocation/free routines on NT (at least, probably other
                    operating systems too) do not do validation of
                    pointers/handles for performance reasons.  This defect
                    is likely to result in memory corruptions and crashes.
                </p>
			</doc>
			<example funcBody="void Typo_280(int arraySize)" sysIncludes="stdlib.h">
				<defectiveSrc><![CDATA[
                    int *pInt= (int *)calloc(arraySize,
                                             sizeof (int));

                    delete pInt;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    int *pInt= (int *)calloc(arraySize,
                                             sizeof (int));

                    free(pInt);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_280.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="7d1ddaf7-a365-4103-8f19-f30b2e45db07" id="283" name="PRIMITIVE_ARRAY_NEW_DELETE_MISMATCH">
			<description>
				<format>
                    Allocation/free mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    %variable% is allocated with array new [], but deleted
                    with scalar delete (see allocation at %location%)
                </format>
				<param name="variable" format="'%ls'"/>
				<param name="location" format="line %d of %ls"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning appears only in C++ code and indicates that
                    the calling function has inconsistently allocated memory
                    with the array <code>new[]</code> operator, but freed it
                    with the scalar <code>delete</code> operator. This is
                    undefined behavior according to the C++ standard;
                    however, when using default global operators, it behaves
                    correctly with the Microsoft VC++ 6.0 and 7.0
                    implementations. In addition to the inherent risk
                    involved in relying on undefined behavior, if global (or
                    class-specific) <code>operator new</code> and
                    <code>operator delete</code> are not compatible with
                    <code>operator new[]</code> and <code>operator
                    delete[]</code>, unexpected results are likely to occur.
                </p>
				<p>
                    The exact ramifications of this defect are difficult to
                    predict. It may result in leaks, memory corruptions, and
                    crashes (in situations where operators have been
                    overridden). In most cases the mismatch may be
                    unimportant, depending on the implementation of the
                    compiler and its libraries. PRE<i>f</i>ast cannot
                    distinguish between these situations.
                </p>
				<p>
                    If memory is allocated with array <code>new[]</code>,
                    it should typically be freed with array
                    <code>delete[]</code>.
                </p>
				<p>
                    In situations where the underlying object in the array
                    is a class type, there is an additional complication:
                    the destructors for the individual objects are not
                    called. In this case, warning 278 is reported instead.
                </p>
				<p>
                    This message is often reported on character (or wide
                    character) arrays.
                </p>
			</doc>
			<example funcBody="void Typo_283(int arraySize)">
				<defectiveSrc><![CDATA[
                    char *str = new char[arraySize];

                    delete str;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char *str = new char[arraySize];

                    delete[] str;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_283.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="d678177b-8e65-4b73-b44a-e40f8a5d7df9" id="300" name="DISCARDED_TOP_LEVEL_EXPRESSION">
			<description>
				<format>
                    Discarded the results of top level expression %expression%
                </format>
				<param name="expression" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    This warning indicates a potential typo or operator
                    precedence error. The offending statement may be a top
                    level expression with no side-effects. Though
                    syntactically correct, this may not be the programmer's
                    intention.
                </p>
			</doc>
			<example funcBody="void Typo_300(int i, int j)">
				<defectiveSrc><![CDATA[
                    i == j; // The boolean result of '==' is ignored. Was '=' intended?
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    i = j;
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_300.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="13c7464f-b664-4967-a9ea-edefa526efd3" id="301" name="DEPRECATED_FUNCTION_USAGE">
			<description>
				<format>
                    %function% is deprecated
                </format>
				<param name="function" format="'%ls'"/>
			</description>
			<additionalInfo>
				<format>
                    please refer to MSDN for more details
                </format>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates the use of deprecated functions. Please
                    refer to MSDN for semantically equivalent newer functions.
                </p>
			</doc>
			<helpURL>http://anyURL/userguide/warning_301.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="561e8c44-658f-423d-ba15-e1ba65af1ad4" id="284" name="OBJECT_AS_STRING_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    object passed as parameter %number% when string is
                    required in call to %function%
                </format>
				<param name="number" format="%d"/>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<consequence>
				<format>
                    Object will be converted to integer, not string
                </format>
			</consequence>
			<doc>
				<p>
                    This warning indicates that the format string specifies
                    that a string is required (e.g., a <code>%s</code>
                    specification for <code>printf</code> or
                    <code>scanf</code>) but a C++ object has been passed
                    instead.
                </p>
				<p>
                    This defect is likely to result in a crash or corruption
                    of some form. Even if the code behaves correctly on
                    32-bit architectures, it is likely to cause problems
                    when porting to 64-bit architectures.
                </p>
				<p>
                    This message is often reported due to passing a C++
                    object implementing some string type (e.g.,
                    <code>std::string</code>,
                    <code>CComBSTR</code> or <code>_bstr_t</code>) into a C
                    printf-style call.  Depending on the implementation of
                    the C++ class (i.e., if the proper cast operators are
                    defined), C++ string objects can often be used
                    transparently whenever C strings are required; however,
                    because parameters to printf-style functions are
                    essentially untyped, no conversion to a string occurs.
                </p>
				<p>
                    Depending on the object, it may be appropriate to insert
                    a <code>static_cast</code> operator to the appropriate
                    string type (e.g., <code>char *</code> or <code>TCHAR
                    *</code>) or to call a member function which returns a
                    string (e.g., <code>c_str()</code>, on instances of
                    <code>std::string</code>).
                </p>
			</doc>
			<example funcBody="void Typo_284(char *buff)" sysIncludes="stdio.h;atlbase.h">
				<defectiveSrc><![CDATA[
                    CComBSTR bstrValue;

                    sprintf(buff,
                            "%ws",
                            bstrValue);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    CComBSTR bstrValue;

                    sprintf(buff,
                            "%ws",
                            static_cast<wchar_t *>(bstrValue));
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_284.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="404ac1ad-a979-4980-901c-bff8bc089b2d" id="302" name="CHAR_WCHAR_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    character string passed as parameter %number% when wide
                    character string is required in call to %function%
                </format>
				<param name="number" format="%d"/>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that the format string specifies
                    that a wide character string is required but a character
                    string is being passed. This defect is likely to
                    result in a crash or corruption of some form.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library.
                </p>
			</doc>
			<example funcBody="void Typo_302" sysIncludes="stdio.h">
				<defectiveSrc><![CDATA[
                    char buff[5] = "hi";

                    wprintf(L"%s", buff);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char buff[5];

                    wprintf(L"%hs", buff);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_302.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="494f3f1e-23ce-4268-80f5-710dbfa2e847" id="303" name="WCHAR_CHAR_ARGUMENT_TO_FORMAT_FUNCTION">
			<description>
				<format>
                    Format string mismatch
                </format>
			</description>
			<additionalInfo>
				<format>
                    wide character string passed as parameter %number% when
                    character string is required in call to %function%
                </format>
				<param name="number" format="%d"/>
				<param name="function" format="'%ls'"/>
			</additionalInfo>
			<doc>
				<p>
                    This warning indicates that the format string specifies
                    that a character string is required but a wide character
                    string is being passed. This defect is likely to
                    result in a crash or corruption of some form.
                </p>
				<p>
                    PRE<i>f</i>ast interprets format strings based on the
                    implementations in the VC7 C run-time library.
                </p>
			</doc>
			<example funcBody="void Typo_303" sysIncludes="stdio.h;wchar.h">
				<defectiveSrc><![CDATA[
                    wchar_t buff[5] = L"hi";

                    printf("%s", buff);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    wchar_t buff[5];

                    printf("%ls", buff);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_303.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="20912b7b-62ed-4473-a0bb-726a4b1f4068" id="304" name="ADDRESSOF_LOCAL_ARRAY">
			<description>
				<format>
                    Address of local array %variable% is the same as the
                    local array variable
                </format>
				<param name="variable" format="'%ls'"/>
			</description>
			<question>
				<format>
                    The address of operation is a no-op. Was it intended
                </format>
			</question>
			<doc>
				<p>
                    This warning indicates a redundant operation that may not
                    be the programmer's intention.
                </p>
			</doc>
			<example funcBody="void Typo_304" sysIncludes="wchar.h">
				<defectiveSrc><![CDATA[
                    wchar_t a[5];
                    wchar_t *p;
                    // Skip over couple of backslashes, but forgot the index.
                    p = &a;
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    wchar_t a[5];
                    wchar_t *p;
                    // Skip over couple of backslashes.
                    p = &a[2];
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_304.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="48aebde9-00ac-42df-8821-200a87e6cd53" id="306" name="INCORRECT_VARARG_FUNCTIONCALL">
			<description>
				<format>
                    Incorrect call to %function%. Consider using %alt_func%
                    which accepts a va_list as an argument
                </format>
				<param name="function" format="'%ls'"/>
				<param name="alt_func" format="'%ls'" display="an alternate function"/>
			</description>
			<doc>
				<p>
                    This warning indicates an incorrect function call. The
                    printf family includes several functions that take a
                    variable list of arguments. However these functions can
                    not be called with a va_list argument. There is a
                    corresponding vprintf family of functions which can be
                    used for such calls.
                </p>
			</doc>
			<example funcBody="void Typo_306(char *pformat, ...)" sysIncludes="stdarg.h;stdio.h">
				<defectiveSrc><![CDATA[
                    va_list v;

                    va_start(v, pformat);
                    printf(pformat, v);
                    va_end(v);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    va_list v;

                    va_start(v, pformat);
                    vprintf(pformat, v);
                    va_end(v);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_306.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="40ae9be1-5b7d-4ecf-b51a-8ca208c41458" id="307" name="WCHAR_TO_BSTR">
			<description>
				<format>
                   Cast between semantically different string types
               </format>
			</description>
			<additionalInfo>
				<format>
                    wchar * to BSTR
                </format>
			</additionalInfo>
			<doc>
				<p>
                    The memory layout and management of wchar * and BSTR are
                    different.  If the function attempts to find the length
                    of the BSTR, free it or pass it to another function or
                    Win32 API that is expecting a BSTR, this call could
                    cause an access violation.
                </p>
			</doc>
			<example funcBody="void Typo_307" sysIncludes="windows.h" globalDecls="extern void foo(BSTR);">
				<defectiveSrc><![CDATA[
                    LPWSTR pSrc = L"Hi";

                    foo(pSrc);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    LPWSTR pSrc = L"Hi";
                    BSTR bSrc = SysAllocString(pSrc);

                    foo(bSrc);
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_307.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="99468443-19e5-413d-b60b-66744bb6b524" id="309" name="PASSING_FUNCTION_UNEXPECTED_NULL">
			<description>
				<format>
                    Potential NULL argument %number% to %function%
               </format>
				<param name="number" format="%d"/>
				<param name="function" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    Passing to an API an unexpected NULL parameter as an arguement.
                </p>
			</doc>
			<example funcBody="void Typo_309" sysIncludes="string.h">
				<defectiveSrc><![CDATA[
                    strcpy(NULL,"data");
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
                    char szDest[20];

                    strcpy(szDest,"data");
                ]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_309.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="79f5ca42-c183-4812-bd21-350c02c18a22" id="335" name="LEAKING_PROCESS_HANDLE">
			<description>
				<format>
                    Leaking process information handle %handlename%
               </format>
				<param name="handlename" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    The process information handles returned by CreateProcess family of function
					need to be closed using CloseHandle. Failure to do so will cause handle leaks.
                </p>
			</doc>
			<example funcBody="void Typo_335">
				<defectiveSrc><![CDATA[
				    PROCESS_INFORMATION pi;
                    CreateProcess("foo.exe", 0, 0, 0, 0, 0, 0, 0, 0, &pi);
                ]]></defectiveSrc>
				<correctedSrc><![CDATA[
				    PROCESS_INFORMATION pi;
                    CreateProcess("foo.exe", 0, 0, 0, 0, 0, 0, 0, 0, &pi);
					CloseHandle(pi.hProcess);
					CloseHandle(pi.hThread);                
				]]></correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_335.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="ce23330b-9b63-4281-91cd-7678d3a8f0f6" id="321" name="FULLPATHNAME_NOT_USED">
			<description>
				<format>
                    Potential use of relative pathname in call to LoadLibrary(A/W/ExA/ExW)
               </format>
			</description>
			<doc>
				<p>
                    Passing a relative pathname to LoadLibrary(A/W/ExA/ExW) may result in picking up the wrong dll inadvertantly, 
					(depending on what the current directory is), thus resulting in a security hole. 
					Programmers developing on the .NET server could ignore this warning by filtering it out.
                </p>
			</doc>
			<example funcBody="void Typo_321">
				<defectiveSrc>
					<![CDATA[
                     LoadLibrary("..\dir2\file.ext");
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                     LoadLibrary("C:\dir1\dir2\file.ext");
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_321.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="0e6adf88-bb54-4b1e-acf7-2a72264e67af" id="322" name="EXCEPT_BLOCK_EMPTY">
			<description>
				<format>
                    Empty _except block
               </format>
			</description>
			<doc>
				<p>
                    No code in the _except block. Some exceptions may go unhandled.
                </p>
			</doc>
			<example funcBody="void Typo_322">
				<defectiveSrc>
					<![CDATA[
                    void main()
					 {
						__try
						{
                         someFunction();
						}
						__except(1)
						{
                           
						}
    
					} 
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                     void main()
					 {
						__try
						{
                          someFunction();
						}
						__except(1)
						{
                          handleException(); 
						}
    
					} 
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_322.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="3467dfc6-3504-4561-83cc-ff493aabc33e" id="323" name="ARITH_OP_ON_BOOL">
			<description>
				<format>
                    Use of arithmetic operator on bool(s)
               </format>
			</description>
			<doc>
				<p>
                  Use of arithmetic operator on bool(s) may yield unexpected values. A true value 
				  can be anything nonzero.
                </p>
			</doc>
			<example funcBody="void Typo_323">
				<defectiveSrc>
					<![CDATA[
                     ans = (a && b) * (a || b); 
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                      
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_323.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="dd420260-000f-4645-bcd5-88340ccdfbf5" id="324" name="STRCPY_INSTEAD_OF_STRCMP">
			<description>
				<format>
                    Potential incorrect use of strcpy
               </format>
			</description>
			<question>
				<format>
                    Did you intend to use strcmp 
                </format>
			</question>
			<example funcBody="void Typo_324">
				<defectiveSrc>
					<![CDATA[
                     (strcpy (name, "dipa") == 0)
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                     (strcmp (name, "dipa") == 0)
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_324.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="215301bf-8af9-40c6-9082-8916b30ce87a" id="325" name="NULL_COMPARISON_FOR_BSTR">
			<description>
				<format>
                    Potential comparison of BSTR with NULL. BSTRs can be (semantically) null in two ways, 
					i.e. the encoded length of the BSTR is 0 or the pointer itself in NULL
               </format>
			</description>
			<question>
				<format>
                    Did you intend to call SysStringLen 
                </format>
			</question>
			<doc>
				<p>
                    BSTRs can be (semantically) null in two ways, i.e. the encoded length of the BSTR is 0
					or the pointer itself in NULL.
                </p>
			</doc>
			<example funcBody="void Typo_325">
				<defectiveSrc>
					<![CDATA[
                    BSTR tstr;
                    int flag;

                    if (tstr == NULL)
                    {
                     flag = 0;
                    } 
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                    BSTR tstr;
                    int flag;

                    if (SysStringLen(tstr) == 0)
                    {
                     flag = 0;
                    }  
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_325.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="04692fe4-717b-453e-9f98-9b502e24331b" id="326" name="CONST_CONST_COMP">
			<description>
				<format>
                    Potential comparison of a constant with constant
               </format>
			</description>
			<doc>
				<p>
                    Comparing a constant with a constant is redundant code.
                </p>
			</doc>
			<example funcBody="void Typo_326">
				<defectiveSrc>
					<![CDATA[
                   (0 != 1)  
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                     
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_326.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="7787d475-a8b1-4f60-a124-265e3df82e02" id="327" name="DEST_BUFFER_INSUFFICIENT">
			<description>
				<format>
                  Potential buffer-overrun. SysAllocStringLen allocates a string and then blindly copies %constant% characters
				  from the string %string%.
				  The code may crash, depending on the data segment layout
               </format>
				<param name="constant" format="'%d'"/>
				<param name="string" format="'%ls'"/>
			</description>
			<doc>
				<format>
                  Potential buffer-overrun. SysAllocStringLen allocates a string and then blindly copies %constant% characters
				  from the string %string%.
				  The code may crash, depending on the data segment layout
               </format>
				<param name="constant" format="'%d'"/>
				<param name="string" format="'%ls'"/>
			</doc>
			<example funcBody="void Typo_327">
				<defectiveSrc>
					<![CDATA[
                     SysAllocStringLen(L"Foo", 5);
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                      SysAllocStringLen(L"Foo", 4);
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_327.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="8a62286e-f5db-459b-ab8c-3038d6f1dfbe" id="328" name="POTENTIAL_ARGUMENT_TYPE_MISMATCH">
			<description>
				<format>
                    %type% passed as parameter %number% when %type% is
                    required in call to %function%
                </format>
				<param name="number" format="%d"/>
				<param name="function" format="'%ls'"/>
				<param name="type" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    For the is* routines, passing an argument of type char may yield unpredictable results. 
					An SBCS or MBCS single-byte character of type char with a value greater than 0x7F is negative. 
					If a char is passed, the compiler may convert the value to a signed int or a signed long.
					This value may be sign-extended by the compiler, with unexpected results.
                </p>
			</doc>
			<example funcBody="void Typo_328">
				<defectiveSrc>
					<![CDATA[
                      char* str;   
					  bool b1 = isdigit(*str);
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                      char* str;   
					  bool b2 = isdigit((unsigned char)*str);
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_328.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="c810365b-8214-4ada-b0e2-8cb4fd437d1e" id="329" name="POTENTIAL_INCORRECT_RETVAL_CHECK">
			<description>
				<format>
                    Return value for a call to %function% should not be checked against
                    %number%
                </format>
				<param name="function" format="'%ls'"/>
				<param name="number" format="%d"/>
			</description>
			<doc>
				<p>
                  CreateFile returns INVALID_HANDLE_VALUE when the operation fails.   
                </p>
			</doc>
			<example funcBody="void Typo_329">
				<defectiveSrc>
					<![CDATA[
                      if (CreateFile() == NULL)
					  {
					  return;
					  }
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                      if (CreateFile() == INVALID_HANDLE_VALUE)
					  {
					  return;
					  }
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_329.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="5A548D52-DC88-4bad-B243-2F5222C168F3" id="380" name="LEGACY_SHUTDOWN_API">
			<description>
				<format>
                    Legacy shutdown API %function% used. Consider using InitiateSystemShutdownEx instead  
                </format>
				<param name="function" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    This warning indicates that a legacy shutdown API has been
					used. The legacy shutdown APIs include InitiateShutdown,
					ExitWindowsEx, and WTSShutdownSystem.
					It is desirable to minimize the number of shutdowns
					or reboots required. However, if a shutdown or reboot is required,
					use InitiateSystemShutdownEx instead.					
                </p>
			</doc>
			<example funcBody="void Typo_380">
				<defectiveSrc>
					<![CDATA[
					  bRet = ExitWindowsEx(EWX_REBOOT,						// shutdown operation
										SHTDN_REASON_MAJOR_OPERATINGSYSTEM);// shutdown reason
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                      bRet = InitiateSystemShutdownEx(lpMachineName,						// computer name
													lpMessage,								// message to display
													0,										// length of time to display
													FALSE,									// force closed option
													TRUE,									// reboot option
													SHTDN_REASON_MAJOR_OPERATINGSYSTEM);	// shutdown reason
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_380.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="316FED04-C283-4e27-8413-C8DC7FEF853C" id="381" name="SHUTDOWN_API">
			<description>
				<format>
                    Shutdown API %function% used with dwReason equal to zero (other) and
					with no lpMessage specified, or with an invalid dwReason. A valid reason
					or message needs to be specified					
                </format>
				<param name="function" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    This warning indicates that IniatiateSystemShutdownEx has been
					used with dwReason = 0 and lpMessage = NULL or lpMessage = "\0", 
					or dwReason &gt;= 0xd0000000.
                </p>
			</doc>
			<example funcBody="void Typo_381">
				<defectiveSrc>
					<![CDATA[
                      bRet = InitiateSystemShutdownEx(NULL,	// computer name
													"",			// message to display (none)
													0,			// length of time to display
													FALSE,		// force closed option
													TRUE,		// reboot option
													0);			// shutdown reason (other)
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                      bRet = InitiateSystemShutdownEx(NULL,	// computer name
													"Reboot needed because...",	// message to display
													0,			// length of time to display
													FALSE,		// force closed option
													TRUE,		// reboot option
													0);			// shutdown reason (other)
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_381.htm</helpURL>
		</DefectDef>
		<!-- -->
		<DefectDef guid="95e07dee-af8d-44cf-a302-7fc428669303" id="382" name="SHUTDOWN_RESOURCE_ID">
			<description>
				<format>
                    Shutdown resource ID %variable% used
                </format>
				<param name="variable" format="'%ls'"/>
			</description>
			<doc>
				<p>
                    This warning indicates that a Resource ID has been used for
					a shutdown message. The Resource ID contains the string 'reboot'
					or 'restartwindows'.
                </p>
			</doc>
			<example funcBody="void Typo_382">
				<defectiveSrc>
					<![CDATA[
					  PCWSTR pszText = SzLoadString(_Module.GetResourceInstance(),
												  IDS_REBOOT_REQUIRED);
                ]]>
				</defectiveSrc>
				<correctedSrc>
					<![CDATA[
                ]]>
				</correctedSrc>
			</example>
			<helpURL>http://anyURL/userguide/warning_382.htm</helpURL>
		</DefectDef>
	</DefectDefGroup>
</DefectDefs>
